// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: chat_external.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum ArticleType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case lot // = 0
  case order // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .lot
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .lot
    case 1: self = .order
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .lot: return 0
    case .order: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ArticleType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ArticleType] = [
    .lot,
    .order,
  ]
}

#endif  // swift(>=4.2)

public struct ChatRouteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: ChatRouteRequest.OneOf_Request? = nil

  public var getRecentChats: GetRecentChatsRequest {
    get {
      if case .getRecentChats(let v)? = request {return v}
      return GetRecentChatsRequest()
    }
    set {request = .getRecentChats(newValue)}
  }

  public var getChatRecentMessages: GetChatMessagesRequest {
    get {
      if case .getChatRecentMessages(let v)? = request {return v}
      return GetChatMessagesRequest()
    }
    set {request = .getChatRecentMessages(newValue)}
  }

  public var sendMessage: SendMessageRequest {
    get {
      if case .sendMessage(let v)? = request {return v}
      return SendMessageRequest()
    }
    set {request = .sendMessage(newValue)}
  }

  public var startChat: StartChatRequest {
    get {
      if case .startChat(let v)? = request {return v}
      return StartChatRequest()
    }
    set {request = .startChat(newValue)}
  }

  public var attachLot: AttachLotRequest {
    get {
      if case .attachLot(let v)? = request {return v}
      return AttachLotRequest()
    }
    set {request = .attachLot(newValue)}
  }

  public var detachLot: DetachLotRequest {
    get {
      if case .detachLot(let v)? = request {return v}
      return DetachLotRequest()
    }
    set {request = .detachLot(newValue)}
  }

  public var sendEvent: SendEventRequest {
    get {
      if case .sendEvent(let v)? = request {return v}
      return SendEventRequest()
    }
    set {request = .sendEvent(newValue)}
  }

  public var getChat: GetChatSummary {
    get {
      if case .getChat(let v)? = request {return v}
      return GetChatSummary()
    }
    set {request = .getChat(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable {
    case getRecentChats(GetRecentChatsRequest)
    case getChatRecentMessages(GetChatMessagesRequest)
    case sendMessage(SendMessageRequest)
    case startChat(StartChatRequest)
    case attachLot(AttachLotRequest)
    case detachLot(DetachLotRequest)
    case sendEvent(SendEventRequest)
    case getChat(GetChatSummary)

  #if !swift(>=4.1)
    public static func ==(lhs: ChatRouteRequest.OneOf_Request, rhs: ChatRouteRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.getRecentChats, .getRecentChats): return {
        guard case .getRecentChats(let l) = lhs, case .getRecentChats(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getChatRecentMessages, .getChatRecentMessages): return {
        guard case .getChatRecentMessages(let l) = lhs, case .getChatRecentMessages(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sendMessage, .sendMessage): return {
        guard case .sendMessage(let l) = lhs, case .sendMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.startChat, .startChat): return {
        guard case .startChat(let l) = lhs, case .startChat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.attachLot, .attachLot): return {
        guard case .attachLot(let l) = lhs, case .attachLot(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.detachLot, .detachLot): return {
        guard case .detachLot(let l) = lhs, case .detachLot(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sendEvent, .sendEvent): return {
        guard case .sendEvent(let l) = lhs, case .sendEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getChat, .getChat): return {
        guard case .getChat(let l) = lhs, case .getChat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Запрос на получение недавних чатов. Если пагинация не указана, возвращает 100 последних чатов.
/// Ответ -> GetRecentChatsResponse
public struct GetRecentChatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pagination: ChatPagination {
    get {return _pagination ?? ChatPagination()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagination: ChatPagination? = nil
}

/// Запрос на получение сообщений в чате. Если пагинация не указана, возвращает 100 последних сообщений.
/// Ответ -> GetRecentChatsResponse
public struct GetChatMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: String = String()

  public var pagination: MessagePagination {
    get {return _pagination ?? MessagePagination()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagination: MessagePagination? = nil
}

/// Отправка сообщения.
/// Без ответа
public struct SendMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: String = String()

  public var type: MessageType = .default

  /// Только для MessageType.DEFAULT
  public var text: String {
    get {return _text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  public var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  public mutating func clearText() {self._text = nil}

  /// Только для MessageType.DEFAULT
  public var imagesUrls: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _text: String? = nil
}

/// Ответ -> ReceiveChatSummary
public struct StartChatRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var interlocutorID: UInt64 = 0

  /// Объявление / услуга, с которой связывается новый чат
  public var article: Article {
    get {return _article ?? Article()}
    set {_article = newValue}
  }
  /// Returns true if `article` has been explicitly set.
  public var hasArticle: Bool {return self._article != nil}
  /// Clears the value of `article`. Subsequent reads from it will return its default value.
  public mutating func clearArticle() {self._article = nil}

  /// Приветсвенный текст
  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _article: Article? = nil
}

public struct Article {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var type: ArticleType = .lot

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Добавление объявления в существующий диалог.
/// Без ответа
public struct AttachLotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var interlocutorID: UInt64 = 0

  public var lotID: UInt64 = 0

  public var chatID: String {
    get {return _chatID ?? String()}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatID: String? = nil
}

/// Удаление объявления из диалога.
/// Без ответа
public struct DetachLotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var interlocutorID: UInt64 = 0

  public var lotID: UInt64 = 0

  public var chatID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Отправка события.
/// Без ответа
public struct SendEventRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: String = String()

  public var event: SendEventRequest.OneOf_Event? = nil

  public var disconnectEvent: DisconnectEvent {
    get {
      if case .disconnectEvent(let v)? = event {return v}
      return DisconnectEvent()
    }
    set {event = .disconnectEvent(newValue)}
  }

  public var changedStatusEvent: ChangeMessagesStatusEvent {
    get {
      if case .changedStatusEvent(let v)? = event {return v}
      return ChangeMessagesStatusEvent()
    }
    set {event = .changedStatusEvent(newValue)}
  }

  public var noPayloadEvent: NoPayloadEvent {
    get {
      if case .noPayloadEvent(let v)? = event {return v}
      return NoPayloadEvent()
    }
    set {event = .noPayloadEvent(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Event: Equatable {
    case disconnectEvent(DisconnectEvent)
    case changedStatusEvent(ChangeMessagesStatusEvent)
    case noPayloadEvent(NoPayloadEvent)

  #if !swift(>=4.1)
    public static func ==(lhs: SendEventRequest.OneOf_Event, rhs: SendEventRequest.OneOf_Event) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.disconnectEvent, .disconnectEvent): return {
        guard case .disconnectEvent(let l) = lhs, case .disconnectEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.changedStatusEvent, .changedStatusEvent): return {
        guard case .changedStatusEvent(let l) = lhs, case .changedStatusEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.noPayloadEvent, .noPayloadEvent): return {
        guard case .noPayloadEvent(let l) = lhs, case .noPayloadEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Ответ -> ReceiveChatSummary
public struct GetChatSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ChatRouteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: ChatRouteResponse.OneOf_Response? = nil

  public var getRecentChats: GetRecentChatsResponse {
    get {
      if case .getRecentChats(let v)? = response {return v}
      return GetRecentChatsResponse()
    }
    set {response = .getRecentChats(newValue)}
  }

  public var getMessagesResponse: GetChatMessagesResponse {
    get {
      if case .getMessagesResponse(let v)? = response {return v}
      return GetChatMessagesResponse()
    }
    set {response = .getMessagesResponse(newValue)}
  }

  public var receiveEvent: ReceiveEvent {
    get {
      if case .receiveEvent(let v)? = response {return v}
      return ReceiveEvent()
    }
    set {response = .receiveEvent(newValue)}
  }

  public var receiveMessage: ReceiveMessage {
    get {
      if case .receiveMessage(let v)? = response {return v}
      return ReceiveMessage()
    }
    set {response = .receiveMessage(newValue)}
  }

  public var chatSummary: ReceiveChatSummary {
    get {
      if case .chatSummary(let v)? = response {return v}
      return ReceiveChatSummary()
    }
    set {response = .chatSummary(newValue)}
  }

  public var error: ErrorMessage {
    get {
      if case .error(let v)? = response {return v}
      return ErrorMessage()
    }
    set {response = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable {
    case getRecentChats(GetRecentChatsResponse)
    case getMessagesResponse(GetChatMessagesResponse)
    case receiveEvent(ReceiveEvent)
    case receiveMessage(ReceiveMessage)
    case chatSummary(ReceiveChatSummary)
    case error(ErrorMessage)

  #if !swift(>=4.1)
    public static func ==(lhs: ChatRouteResponse.OneOf_Response, rhs: ChatRouteResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.getRecentChats, .getRecentChats): return {
        guard case .getRecentChats(let l) = lhs, case .getRecentChats(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getMessagesResponse, .getMessagesResponse): return {
        guard case .getMessagesResponse(let l) = lhs, case .getMessagesResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.receiveEvent, .receiveEvent): return {
        guard case .receiveEvent(let l) = lhs, case .receiveEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.receiveMessage, .receiveMessage): return {
        guard case .receiveMessage(let l) = lhs, case .receiveMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chatSummary, .chatSummary): return {
        guard case .chatSummary(let l) = lhs, case .chatSummary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Недавние чаты
public struct GetRecentChatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chats: [Chat] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Сообщения в чате
public struct GetChatMessagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messages: [Message] = []

  public var chatID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Событие в чате.
/// Указывает на то, что собеседник в обозначенном чате совершил определенное действие
public struct ReceiveEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: String = String()

  public var event: ReceiveEvent.OneOf_Event? = nil

  public var disconnectEvent: DisconnectEvent {
    get {
      if case .disconnectEvent(let v)? = event {return v}
      return DisconnectEvent()
    }
    set {event = .disconnectEvent(newValue)}
  }

  public var changedStatusEvent: ChangeMessagesStatusEvent {
    get {
      if case .changedStatusEvent(let v)? = event {return v}
      return ChangeMessagesStatusEvent()
    }
    set {event = .changedStatusEvent(newValue)}
  }

  public var noPayloadEvent: NoPayloadEvent {
    get {
      if case .noPayloadEvent(let v)? = event {return v}
      return NoPayloadEvent()
    }
    set {event = .noPayloadEvent(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Event: Equatable {
    case disconnectEvent(DisconnectEvent)
    case changedStatusEvent(ChangeMessagesStatusEvent)
    case noPayloadEvent(NoPayloadEvent)

  #if !swift(>=4.1)
    public static func ==(lhs: ReceiveEvent.OneOf_Event, rhs: ReceiveEvent.OneOf_Event) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.disconnectEvent, .disconnectEvent): return {
        guard case .disconnectEvent(let l) = lhs, case .disconnectEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.changedStatusEvent, .changedStatusEvent): return {
        guard case .changedStatusEvent(let l) = lhs, case .changedStatusEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.noPayloadEvent, .noPayloadEvent): return {
        guard case .noPayloadEvent(let l) = lhs, case .noPayloadEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Входящее сообщение
public struct ReceiveMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: Message {
    get {return _message ?? Message()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var chatID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _message: Message? = nil
}

/// Полное представление чата
public struct ReceiveChatSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chat: Chat {
    get {return _chat ?? Chat()}
    set {_chat = newValue}
  }
  /// Returns true if `chat` has been explicitly set.
  public var hasChat: Bool {return self._chat != nil}
  /// Clears the value of `chat`. Subsequent reads from it will return its default value.
  public mutating func clearChat() {self._chat = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chat: Chat? = nil
}

/// Представление ошибки, возникшей в результате стриминга. Используется для предотвращения обрыва соединения
public struct ErrorMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: UInt32 = 0

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension ArticleType: @unchecked Sendable {}
extension ChatRouteRequest: @unchecked Sendable {}
extension ChatRouteRequest.OneOf_Request: @unchecked Sendable {}
extension GetRecentChatsRequest: @unchecked Sendable {}
extension GetChatMessagesRequest: @unchecked Sendable {}
extension SendMessageRequest: @unchecked Sendable {}
extension StartChatRequest: @unchecked Sendable {}
extension Article: @unchecked Sendable {}
extension AttachLotRequest: @unchecked Sendable {}
extension DetachLotRequest: @unchecked Sendable {}
extension SendEventRequest: @unchecked Sendable {}
extension SendEventRequest.OneOf_Event: @unchecked Sendable {}
extension GetChatSummary: @unchecked Sendable {}
extension ChatRouteResponse: @unchecked Sendable {}
extension ChatRouteResponse.OneOf_Response: @unchecked Sendable {}
extension GetRecentChatsResponse: @unchecked Sendable {}
extension GetChatMessagesResponse: @unchecked Sendable {}
extension ReceiveEvent: @unchecked Sendable {}
extension ReceiveEvent.OneOf_Event: @unchecked Sendable {}
extension ReceiveMessage: @unchecked Sendable {}
extension ReceiveChatSummary: @unchecked Sendable {}
extension ErrorMessage: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ru.zveron.contract.chat"

extension ArticleType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOT"),
    1: .same(proto: "ORDER"),
  ]
}

extension ChatRouteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatRouteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "get_recent_chats"),
    2: .standard(proto: "get_chat_recent_messages"),
    3: .standard(proto: "send_message"),
    4: .standard(proto: "start_chat"),
    5: .standard(proto: "attach_lot"),
    6: .standard(proto: "detach_lot"),
    7: .standard(proto: "send_event"),
    8: .standard(proto: "get_chat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: GetRecentChatsRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getRecentChats(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getRecentChats(v)
        }
      }()
      case 2: try {
        var v: GetChatMessagesRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getChatRecentMessages(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getChatRecentMessages(v)
        }
      }()
      case 3: try {
        var v: SendMessageRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .sendMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .sendMessage(v)
        }
      }()
      case 4: try {
        var v: StartChatRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .startChat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .startChat(v)
        }
      }()
      case 5: try {
        var v: AttachLotRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .attachLot(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .attachLot(v)
        }
      }()
      case 6: try {
        var v: DetachLotRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .detachLot(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .detachLot(v)
        }
      }()
      case 7: try {
        var v: SendEventRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .sendEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .sendEvent(v)
        }
      }()
      case 8: try {
        var v: GetChatSummary?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getChat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getChat(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .getRecentChats?: try {
      guard case .getRecentChats(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getChatRecentMessages?: try {
      guard case .getChatRecentMessages(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .sendMessage?: try {
      guard case .sendMessage(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .startChat?: try {
      guard case .startChat(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .attachLot?: try {
      guard case .attachLot(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .detachLot?: try {
      guard case .detachLot(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .sendEvent?: try {
      guard case .sendEvent(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .getChat?: try {
      guard case .getChat(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChatRouteRequest, rhs: ChatRouteRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetRecentChatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRecentChatsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pagination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetRecentChatsRequest, rhs: GetRecentChatsRequest) -> Bool {
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetChatMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "pagination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chatID.isEmpty {
      try visitor.visitSingularStringField(value: self.chatID, fieldNumber: 1)
    }
    try { if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetChatMessagesRequest, rhs: GetChatMessagesRequest) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SendMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendMessageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "type"),
    3: .same(proto: "text"),
    4: .standard(proto: "images_urls"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chatID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.imagesUrls) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chatID.isEmpty {
      try visitor.visitSingularStringField(value: self.chatID, fieldNumber: 1)
    }
    if self.type != .default {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.imagesUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.imagesUrls, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SendMessageRequest, rhs: SendMessageRequest) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.type != rhs.type {return false}
    if lhs._text != rhs._text {return false}
    if lhs.imagesUrls != rhs.imagesUrls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StartChatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartChatRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "interlocutor_id"),
    2: .same(proto: "article"),
    3: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.interlocutorID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._article) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.interlocutorID != 0 {
      try visitor.visitSingularUInt64Field(value: self.interlocutorID, fieldNumber: 1)
    }
    try { if let v = self._article {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StartChatRequest, rhs: StartChatRequest) -> Bool {
    if lhs.interlocutorID != rhs.interlocutorID {return false}
    if lhs._article != rhs._article {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Article: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Article"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.type != .lot {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Article, rhs: Article) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AttachLotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AttachLotRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "interlocutor_id"),
    2: .standard(proto: "lot_id"),
    3: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.interlocutorID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.lotID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.interlocutorID != 0 {
      try visitor.visitSingularUInt64Field(value: self.interlocutorID, fieldNumber: 1)
    }
    if self.lotID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lotID, fieldNumber: 2)
    }
    try { if let v = self._chatID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AttachLotRequest, rhs: AttachLotRequest) -> Bool {
    if lhs.interlocutorID != rhs.interlocutorID {return false}
    if lhs.lotID != rhs.lotID {return false}
    if lhs._chatID != rhs._chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DetachLotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DetachLotRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "interlocutor_id"),
    2: .standard(proto: "lot_id"),
    3: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.interlocutorID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.lotID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.interlocutorID != 0 {
      try visitor.visitSingularUInt64Field(value: self.interlocutorID, fieldNumber: 1)
    }
    if self.lotID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lotID, fieldNumber: 2)
    }
    if !self.chatID.isEmpty {
      try visitor.visitSingularStringField(value: self.chatID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DetachLotRequest, rhs: DetachLotRequest) -> Bool {
    if lhs.interlocutorID != rhs.interlocutorID {return false}
    if lhs.lotID != rhs.lotID {return false}
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SendEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendEventRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "disconnect_event"),
    3: .standard(proto: "changed_status_event"),
    4: .standard(proto: "no_payload_event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chatID) }()
      case 2: try {
        var v: DisconnectEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .disconnectEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .disconnectEvent(v)
        }
      }()
      case 3: try {
        var v: ChangeMessagesStatusEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .changedStatusEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .changedStatusEvent(v)
        }
      }()
      case 4: try {
        var v: NoPayloadEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .noPayloadEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .noPayloadEvent(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chatID.isEmpty {
      try visitor.visitSingularStringField(value: self.chatID, fieldNumber: 1)
    }
    switch self.event {
    case .disconnectEvent?: try {
      guard case .disconnectEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .changedStatusEvent?: try {
      guard case .changedStatusEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .noPayloadEvent?: try {
      guard case .noPayloadEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SendEventRequest, rhs: SendEventRequest) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetChatSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chatID.isEmpty {
      try visitor.visitSingularStringField(value: self.chatID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetChatSummary, rhs: GetChatSummary) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChatRouteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatRouteResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "get_recent_chats"),
    2: .standard(proto: "get_messages_response"),
    3: .standard(proto: "receive_event"),
    4: .standard(proto: "receive_message"),
    5: .same(proto: "chatSummary"),
    6: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: GetRecentChatsResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getRecentChats(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getRecentChats(v)
        }
      }()
      case 2: try {
        var v: GetChatMessagesResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getMessagesResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getMessagesResponse(v)
        }
      }()
      case 3: try {
        var v: ReceiveEvent?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .receiveEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .receiveEvent(v)
        }
      }()
      case 4: try {
        var v: ReceiveMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .receiveMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .receiveMessage(v)
        }
      }()
      case 5: try {
        var v: ReceiveChatSummary?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .chatSummary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .chatSummary(v)
        }
      }()
      case 6: try {
        var v: ErrorMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .getRecentChats?: try {
      guard case .getRecentChats(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getMessagesResponse?: try {
      guard case .getMessagesResponse(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .receiveEvent?: try {
      guard case .receiveEvent(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .receiveMessage?: try {
      guard case .receiveMessage(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .chatSummary?: try {
      guard case .chatSummary(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChatRouteResponse, rhs: ChatRouteResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetRecentChatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRecentChatsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.chats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chats, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetRecentChatsResponse, rhs: GetRecentChatsResponse) -> Bool {
    if lhs.chats != rhs.chats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetChatMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatMessagesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
    2: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    if !self.chatID.isEmpty {
      try visitor.visitSingularStringField(value: self.chatID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetChatMessagesResponse, rhs: GetChatMessagesResponse) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReceiveEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReceiveEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "disconnect_event"),
    3: .standard(proto: "changed_status_event"),
    4: .standard(proto: "no_payload_event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chatID) }()
      case 2: try {
        var v: DisconnectEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .disconnectEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .disconnectEvent(v)
        }
      }()
      case 3: try {
        var v: ChangeMessagesStatusEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .changedStatusEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .changedStatusEvent(v)
        }
      }()
      case 4: try {
        var v: NoPayloadEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .noPayloadEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .noPayloadEvent(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chatID.isEmpty {
      try visitor.visitSingularStringField(value: self.chatID, fieldNumber: 1)
    }
    switch self.event {
    case .disconnectEvent?: try {
      guard case .disconnectEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .changedStatusEvent?: try {
      guard case .changedStatusEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .noPayloadEvent?: try {
      guard case .noPayloadEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReceiveEvent, rhs: ReceiveEvent) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReceiveMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReceiveMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.chatID.isEmpty {
      try visitor.visitSingularStringField(value: self.chatID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReceiveMessage, rhs: ReceiveMessage) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReceiveChatSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReceiveChatSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ReceiveChatSummary, rhs: ReceiveChatSummary) -> Bool {
    if lhs._chat != rhs._chat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ErrorMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != 0 {
      try visitor.visitSingularUInt32Field(value: self.status, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ErrorMessage, rhs: ErrorMessage) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
