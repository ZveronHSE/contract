// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: external_lot.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum TypeSort: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Сортировка по возрастанию
  case asc // = 0

  /// Сортировка по убыванию
  case desc // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .asc
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .asc
    case 1: self = .desc
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .asc: return 0
    case .desc: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TypeSort: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TypeSort] = [
    .asc,
    .desc,
  ]
}

#endif  // swift(>=4.2)

public enum Field: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case price // = 0

  /// Тип объявления
  case lotFormID // = 1

  /// Когда создано объявление
  case dateCreation // = 2

  /// Гендер у объявления, если продают животного.
  case gender // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .price
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .price
    case 1: self = .lotFormID
    case 2: self = .dateCreation
    case 3: self = .gender
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .price: return 0
    case .lotFormID: return 1
    case .dateCreation: return 2
    case .gender: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Field: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Field] = [
    .price,
    .lotFormID,
    .dateCreation,
    .gender,
  ]
}

#endif  // swift(>=4.2)

public enum Operation: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Поле равно значению.
  case equality // = 0

  /// Поле не равно значению.
  case negation // = 1

  /// Поле больше, чем
  case greaterThan // = 2

  /// Поле больше или равно значению.
  case greaterThanEquality // = 3

  /// Поле меньше, чем значение.
  case lessThan // = 4

  /// Поле меньше или равно значению.
  case lessThanEquality // = 5

  /// Поле входит в несколько значений, значения передаются через запятую, например: price==15,346,765,8794
  case `in` // = 6

  /// Поле не входит в несколько значений, значения передаются через запятую, например: price==15,346,765,8794
  case notIn // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .equality
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .equality
    case 1: self = .negation
    case 2: self = .greaterThan
    case 3: self = .greaterThanEquality
    case 4: self = .lessThan
    case 5: self = .lessThanEquality
    case 6: self = .in
    case 7: self = .notIn
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .equality: return 0
    case .negation: return 1
    case .greaterThan: return 2
    case .greaterThanEquality: return 3
    case .lessThan: return 4
    case .lessThanEquality: return 5
    case .in: return 6
    case .notIn: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Operation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Operation] = [
    .equality,
    .negation,
    .greaterThan,
    .greaterThanEquality,
    .lessThan,
    .lessThanEquality,
    .in,
    .notIn,
  ]
}

#endif  // swift(>=4.2)

public enum ClosingLotReason: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Продал на этом сайте
  case sold // = 0

  /// Продал в другом месте
  case soldSomewhere // = 1

  /// Продажа неактуальна
  case irrelevant // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .sold
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sold
    case 1: self = .soldSomewhere
    case 2: self = .irrelevant
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .sold: return 0
    case .soldSomewhere: return 1
    case .irrelevant: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ClosingLotReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [ClosingLotReason] = [
    .sold,
    .soldSomewhere,
    .irrelevant,
  ]
}

#endif  // swift(>=4.2)

public struct WaterfallRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Количество элементов запрашиваемых на страницу
  public var pageSize: Int32 = 0

  /// По какому слову искать в объявлениях, например, по "собака"
  public var query: String {
    get {return _query ?? String()}
    set {_query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  public var hasQuery: Bool {return self._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  public mutating func clearQuery() {self._query = nil}

  /// По какому категорию отбирать объявления (учитываются и все дочерние категории)
  public var categoryID: Int32 {
    get {return _categoryID ?? 0}
    set {_categoryID = newValue}
  }
  /// Returns true if `categoryID` has been explicitly set.
  public var hasCategoryID: Bool {return self._categoryID != nil}
  /// Clears the value of `categoryID`. Subsequent reads from it will return its default value.
  public mutating func clearCategoryID() {self._categoryID = nil}

  /// Фильтровать по различным полям объявления, кроме параметров. (например, цена, дата и тд)
  public var filters: [Filter] = []

  /// Фильтровать по параметрам объявления, если они заданы
  public var parameters: [Parameter] = []

  /// По какому признаку нужно сортировать объявления
  public var sort: Sort {
    get {return _sort ?? Sort()}
    set {_sort = newValue}
  }
  /// Returns true if `sort` has been explicitly set.
  public var hasSort: Bool {return self._sort != nil}
  /// Clears the value of `sort`. Subsequent reads from it will return its default value.
  public mutating func clearSort() {self._sort = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _query: String? = nil
  fileprivate var _categoryID: Int32? = nil
  fileprivate var _sort: Sort? = nil
}

public struct Sort {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sortBy: Sort.SortBy = .price

  public var typeSort: TypeSort = .asc

  /// Данные последнего объявления, который был на прошлой странице(если запрос от второй страницы и последующей)
  public var lastLot: LastLot {
    get {return _lastLot ?? LastLot()}
    set {_lastLot = newValue}
  }
  /// Returns true if `lastLot` has been explicitly set.
  public var hasLastLot: Bool {return self._lastLot != nil}
  /// Clears the value of `lastLot`. Subsequent reads from it will return its default value.
  public mutating func clearLastLot() {self._lastLot = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum SortBy: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case price // = 0
    case date // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .price
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .price
      case 1: self = .date
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .price: return 0
      case .date: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _lastLot: LastLot? = nil
}

#if swift(>=4.2)

extension Sort.SortBy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sort.SortBy] = [
    .price,
    .date,
  ]
}

#endif  // swift(>=4.2)

public struct LastLot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  /// Дата создания
  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  public var price: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Filter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field: Field = .price

  public var operation: Operation = .equality

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct WaterfallResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lots: [Lot] = []

  /// Данные последнего объявления, необходимые для сортировки и работы водопада
  public var lastLot: LastLot {
    get {return _lastLot ?? LastLot()}
    set {_lastLot = newValue}
  }
  /// Returns true if `lastLot` has been explicitly set.
  public var hasLastLot: Bool {return self._lastLot != nil}
  /// Clears the value of `lastLot`. Subsequent reads from it will return its default value.
  public mutating func clearLastLot() {self._lastLot = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lastLot: LastLot? = nil
}

public struct CreateLotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var photos: [Photo] = []

  /// Заданные параметры объявления
  public var parameters: Dictionary<Int32,String> = [:]

  public var description_p: String = String()

  public var price: Int32 = 0

  /// Количество выбранных связей, их может быть 1 или 2.
  public var communicationChannel: [CommunicationChannel] = []

  /// Это может отсутствовать, если гендера нет для объявления, например, для товаров.
  public var gender: Gender {
    get {return _gender ?? .female}
    set {_gender = newValue}
  }
  /// Returns true if `gender` has been explicitly set.
  public var hasGender: Bool {return self._gender != nil}
  /// Clears the value of `gender`. Subsequent reads from it will return its default value.
  public mutating func clearGender() {self._gender = nil}

  public var address: FullAddress {
    get {return _address ?? FullAddress()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {self._address = nil}

  public var lotFormID: Int32 = 0

  public var categoryID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _gender: Gender? = nil
  fileprivate var _address: FullAddress? = nil
}

/// Path /api/lot/edit, ответ будет в виде CardLot
public struct EditLotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID объявления
  public var id: Int64 = 0

  public var title: String = String()

  public var photos: [Photo] = []

  /// Заданные параметры объявления
  public var parameters: Dictionary<Int32,String> = [:]

  public var description_p: String = String()

  public var price: Int32 = 0

  /// Количество выбранных связей, их может быть 1 или 2.
  public var communicationChannel: [CommunicationChannel] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Path /api/lot/close, ответ будет пустым
public struct CloseLotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID объявления
  public var id: Int64 = 0

  public var closingLotReason: ClosingLotReason = .sold

  /// Идентификатор покупателя, если объявление было продано на этом сайте
  public var customerID: Int64 {
    get {return _customerID ?? 0}
    set {_customerID = newValue}
  }
  /// Returns true if `customerID` has been explicitly set.
  public var hasCustomerID: Bool {return self._customerID != nil}
  /// Clears the value of `customerID`. Subsequent reads from it will return its default value.
  public mutating func clearCustomerID() {self._customerID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _customerID: Int64? = nil
}

public struct FullAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var region: String {
    get {return _region ?? String()}
    set {_region = newValue}
  }
  /// Returns true if `region` has been explicitly set.
  public var hasRegion: Bool {return self._region != nil}
  /// Clears the value of `region`. Subsequent reads from it will return its default value.
  public mutating func clearRegion() {self._region = nil}

  public var district: String {
    get {return _district ?? String()}
    set {_district = newValue}
  }
  /// Returns true if `district` has been explicitly set.
  public var hasDistrict: Bool {return self._district != nil}
  /// Clears the value of `district`. Subsequent reads from it will return its default value.
  public mutating func clearDistrict() {self._district = nil}

  public var town: String {
    get {return _town ?? String()}
    set {_town = newValue}
  }
  /// Returns true if `town` has been explicitly set.
  public var hasTown: Bool {return self._town != nil}
  /// Clears the value of `town`. Subsequent reads from it will return its default value.
  public mutating func clearTown() {self._town = nil}

  public var street: String {
    get {return _street ?? String()}
    set {_street = newValue}
  }
  /// Returns true if `street` has been explicitly set.
  public var hasStreet: Bool {return self._street != nil}
  /// Clears the value of `street`. Subsequent reads from it will return its default value.
  public mutating func clearStreet() {self._street = nil}

  public var house: String {
    get {return _house ?? String()}
    set {_house = newValue}
  }
  /// Returns true if `house` has been explicitly set.
  public var hasHouse: Bool {return self._house != nil}
  /// Clears the value of `house`. Subsequent reads from it will return its default value.
  public mutating func clearHouse() {self._house = nil}

  public var longitude: Double = 0

  public var latitude: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _region: String? = nil
  fileprivate var _district: String? = nil
  fileprivate var _town: String? = nil
  fileprivate var _street: String? = nil
  fileprivate var _house: String? = nil
}

public struct CardLotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID объявления
  public var id: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CardLot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID объявления
  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  public var photos: [Photo] {
    get {return _storage._photos}
    set {_uniqueStorage()._photos = newValue}
  }

  /// Это может отсутствовать, если гендера нет для объявления, например, для товаров.
  public var gender: Gender {
    get {return _storage._gender ?? .female}
    set {_uniqueStorage()._gender = newValue}
  }
  /// Returns true if `gender` has been explicitly set.
  public var hasGender: Bool {return _storage._gender != nil}
  /// Clears the value of `gender`. Subsequent reads from it will return its default value.
  public mutating func clearGender() {_uniqueStorage()._gender = nil}

  public var address: Address {
    get {return _storage._address ?? Address()}
    set {_uniqueStorage()._address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return _storage._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {_uniqueStorage()._address = nil}

  /// Заданные параметры объявления
  public var parameters: [Parameter] {
    get {return _storage._parameters}
    set {_uniqueStorage()._parameters = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// Если цены нет, то придет текст, например "Договорная", а если есть цена - то число. Этим и обусловен выбор string тут.
  public var price: String {
    get {return _storage._price}
    set {_uniqueStorage()._price = newValue}
  }

  /// Красить кнопку "Избранное", если оно уже и так добавлено в избранное, иначе нет.
  public var favorite: Bool {
    get {return _storage._favorite}
    set {_uniqueStorage()._favorite = newValue}
  }

  /// Является ли это объявление собственным, и если да, то нужно будет скрыть кнопку "Избранное" и отображать кнопку "Редактировать".
  public var own: Bool {
    get {return _storage._own}
    set {_uniqueStorage()._own = newValue}
  }

  /// Может ли пользователь добавлять отзыв на это объявление, если да, то отображать кнопку.
  public var canAddReview: Bool {
    get {return _storage._canAddReview}
    set {_uniqueStorage()._canAddReview = newValue}
  }

  public var contact: Contact {
    get {return _storage._contact ?? Contact()}
    set {_uniqueStorage()._contact = newValue}
  }
  /// Returns true if `contact` has been explicitly set.
  public var hasContact: Bool {return _storage._contact != nil}
  /// Clears the value of `contact`. Subsequent reads from it will return its default value.
  public mutating func clearContact() {_uniqueStorage()._contact = nil}

  public var seller: Seller {
    get {return _storage._seller ?? Seller()}
    set {_uniqueStorage()._seller = newValue}
  }
  /// Returns true if `seller` has been explicitly set.
  public var hasSeller: Bool {return _storage._seller != nil}
  /// Clears the value of `seller`. Subsequent reads from it will return its default value.
  public mutating func clearSeller() {_uniqueStorage()._seller = nil}

  public var statistics: Statistics {
    get {return _storage._statistics ?? Statistics()}
    set {_uniqueStorage()._statistics = newValue}
  }
  /// Returns true if `statistics` has been explicitly set.
  public var hasStatistics: Bool {return _storage._statistics != nil}
  /// Clears the value of `statistics`. Subsequent reads from it will return its default value.
  public mutating func clearStatistics() {_uniqueStorage()._statistics = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Статистика объявления
public struct Statistics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Количество просмотров
  public var view: Int32 = 0

  /// Количество добавленных в избранное
  public var favorite: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Seller {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  public var name: String = String()

  public var surname: String = String()

  /// Рейтинг продавца
  public var rating: Double = 0

  public var online: Bool = false

  public var imageURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Contact {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Какие способы связи были выбраны.
  public var communicationChannel: [CommunicationChannel] = []

  /// Ссылки для выбранных способов связи.
  public var channelLink: ChannelLink {
    get {return _channelLink ?? ChannelLink()}
    set {_channelLink = newValue}
  }
  /// Returns true if `channelLink` has been explicitly set.
  public var hasChannelLink: Bool {return self._channelLink != nil}
  /// Clears the value of `channelLink`. Subsequent reads from it will return its default value.
  public mutating func clearChannelLink() {self._channelLink = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _channelLink: ChannelLink? = nil
}

/// Отображается информация про тех или иных способах только в тех случаях, когда они были выбраны в CommunicationChannel
public struct ChannelLink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Номер телефона в формате +79994443322
  public var phone: String {
    get {return _phone ?? String()}
    set {_phone = newValue}
  }
  /// Returns true if `phone` has been explicitly set.
  public var hasPhone: Bool {return self._phone != nil}
  /// Clears the value of `phone`. Subsequent reads from it will return its default value.
  public mutating func clearPhone() {self._phone = nil}

  /// Ссылка на профиль в ВК
  public var vk: String {
    get {return _vk ?? String()}
    set {_vk = newValue}
  }
  /// Returns true if `vk` has been explicitly set.
  public var hasVk: Bool {return self._vk != nil}
  /// Clears the value of `vk`. Subsequent reads from it will return its default value.
  public mutating func clearVk() {self._vk = nil}

  /// Ссылка на почту для создания письма (emailto:..)
  public var email: String {
    get {return _email ?? String()}
    set {_email = newValue}
  }
  /// Returns true if `email` has been explicitly set.
  public var hasEmail: Bool {return self._email != nil}
  /// Clears the value of `email`. Subsequent reads from it will return its default value.
  public mutating func clearEmail() {self._email = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _phone: String? = nil
  fileprivate var _vk: String? = nil
  fileprivate var _email: String? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension TypeSort: @unchecked Sendable {}
extension Field: @unchecked Sendable {}
extension Operation: @unchecked Sendable {}
extension ClosingLotReason: @unchecked Sendable {}
extension WaterfallRequest: @unchecked Sendable {}
extension Sort: @unchecked Sendable {}
extension Sort.SortBy: @unchecked Sendable {}
extension LastLot: @unchecked Sendable {}
extension Filter: @unchecked Sendable {}
extension WaterfallResponse: @unchecked Sendable {}
extension CreateLotRequest: @unchecked Sendable {}
extension EditLotRequest: @unchecked Sendable {}
extension CloseLotRequest: @unchecked Sendable {}
extension FullAddress: @unchecked Sendable {}
extension CardLotRequest: @unchecked Sendable {}
extension CardLot: @unchecked Sendable {}
extension Statistics: @unchecked Sendable {}
extension Seller: @unchecked Sendable {}
extension Contact: @unchecked Sendable {}
extension ChannelLink: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ru.zveron.contract.lot"

extension TypeSort: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ASC"),
    1: .same(proto: "DESC"),
  ]
}

extension Field: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRICE"),
    1: .same(proto: "LOT_FORM_ID"),
    2: .same(proto: "DATE_CREATION"),
    3: .same(proto: "GENDER"),
  ]
}

extension Operation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EQUALITY"),
    1: .same(proto: "NEGATION"),
    2: .same(proto: "GREATER_THAN"),
    3: .same(proto: "GREATER_THAN_EQUALITY"),
    4: .same(proto: "LESS_THAN"),
    5: .same(proto: "LESS_THAN_EQUALITY"),
    6: .same(proto: "IN"),
    7: .same(proto: "NOT_IN"),
  ]
}

extension ClosingLotReason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOLD"),
    1: .same(proto: "SOLD_SOMEWHERE"),
    2: .same(proto: "IRRELEVANT"),
  ]
}

extension WaterfallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaterfallRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_size"),
    2: .same(proto: "query"),
    3: .standard(proto: "category_id"),
    4: .same(proto: "filters"),
    5: .same(proto: "parameters"),
    6: .same(proto: "sort"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._query) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._categoryID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.parameters) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._sort) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    try { if let v = self._query {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._categoryID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 4)
    }
    if !self.parameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameters, fieldNumber: 5)
    }
    try { if let v = self._sort {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WaterfallRequest, rhs: WaterfallRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs._query != rhs._query {return false}
    if lhs._categoryID != rhs._categoryID {return false}
    if lhs.filters != rhs.filters {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs._sort != rhs._sort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sort: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Sort"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sort_by"),
    2: .standard(proto: "type_sort"),
    3: .standard(proto: "last_lot"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.sortBy) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.typeSort) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lastLot) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.sortBy != .price {
      try visitor.visitSingularEnumField(value: self.sortBy, fieldNumber: 1)
    }
    if self.typeSort != .asc {
      try visitor.visitSingularEnumField(value: self.typeSort, fieldNumber: 2)
    }
    try { if let v = self._lastLot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sort, rhs: Sort) -> Bool {
    if lhs.sortBy != rhs.sortBy {return false}
    if lhs.typeSort != rhs.typeSort {return false}
    if lhs._lastLot != rhs._lastLot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sort.SortBy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRICE"),
    1: .same(proto: "DATE"),
  ]
}

extension LastLot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LastLot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "date"),
    3: .same(proto: "price"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.price) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.price != 0 {
      try visitor.visitSingularInt32Field(value: self.price, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LastLot, rhs: LastLot) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._date != rhs._date {return false}
    if lhs.price != rhs.price {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .same(proto: "operation"),
    3: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.field) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.field != .price {
      try visitor.visitSingularEnumField(value: self.field, fieldNumber: 1)
    }
    if self.operation != .equality {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Filter, rhs: Filter) -> Bool {
    if lhs.field != rhs.field {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WaterfallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaterfallResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lots"),
    2: .standard(proto: "last_lot"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.lots) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lastLot) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.lots.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lots, fieldNumber: 1)
    }
    try { if let v = self._lastLot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: WaterfallResponse, rhs: WaterfallResponse) -> Bool {
    if lhs.lots != rhs.lots {return false}
    if lhs._lastLot != rhs._lastLot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreateLotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateLotRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "photos"),
    3: .same(proto: "parameters"),
    4: .same(proto: "description"),
    5: .same(proto: "price"),
    6: .standard(proto: "communication_channel"),
    7: .same(proto: "gender"),
    8: .same(proto: "address"),
    9: .standard(proto: "lot_form_id"),
    10: .standard(proto: "category_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.photos) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufString>.self, value: &self.parameters) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.price) }()
      case 6: try { try decoder.decodeRepeatedEnumField(value: &self.communicationChannel) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._gender) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.lotFormID) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.categoryID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.photos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.photos, fieldNumber: 2)
    }
    if !self.parameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufString>.self, value: self.parameters, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if self.price != 0 {
      try visitor.visitSingularInt32Field(value: self.price, fieldNumber: 5)
    }
    if !self.communicationChannel.isEmpty {
      try visitor.visitPackedEnumField(value: self.communicationChannel, fieldNumber: 6)
    }
    try { if let v = self._gender {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.lotFormID != 0 {
      try visitor.visitSingularInt32Field(value: self.lotFormID, fieldNumber: 9)
    }
    if self.categoryID != 0 {
      try visitor.visitSingularInt32Field(value: self.categoryID, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CreateLotRequest, rhs: CreateLotRequest) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.photos != rhs.photos {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.price != rhs.price {return false}
    if lhs.communicationChannel != rhs.communicationChannel {return false}
    if lhs._gender != rhs._gender {return false}
    if lhs._address != rhs._address {return false}
    if lhs.lotFormID != rhs.lotFormID {return false}
    if lhs.categoryID != rhs.categoryID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EditLotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditLotRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
    3: .same(proto: "photos"),
    4: .same(proto: "parameters"),
    5: .same(proto: "description"),
    6: .same(proto: "price"),
    7: .standard(proto: "communication_channel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.photos) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufString>.self, value: &self.parameters) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.price) }()
      case 7: try { try decoder.decodeRepeatedEnumField(value: &self.communicationChannel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.photos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.photos, fieldNumber: 3)
    }
    if !self.parameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufString>.self, value: self.parameters, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    if self.price != 0 {
      try visitor.visitSingularInt32Field(value: self.price, fieldNumber: 6)
    }
    if !self.communicationChannel.isEmpty {
      try visitor.visitPackedEnumField(value: self.communicationChannel, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EditLotRequest, rhs: EditLotRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.photos != rhs.photos {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.price != rhs.price {return false}
    if lhs.communicationChannel != rhs.communicationChannel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CloseLotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloseLotRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "closing_lot_reason"),
    3: .standard(proto: "customer_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.closingLotReason) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._customerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.closingLotReason != .sold {
      try visitor.visitSingularEnumField(value: self.closingLotReason, fieldNumber: 2)
    }
    try { if let v = self._customerID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CloseLotRequest, rhs: CloseLotRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.closingLotReason != rhs.closingLotReason {return false}
    if lhs._customerID != rhs._customerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FullAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FullAddress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "region"),
    2: .same(proto: "district"),
    3: .same(proto: "town"),
    4: .same(proto: "street"),
    5: .same(proto: "house"),
    6: .same(proto: "longitude"),
    7: .same(proto: "latitude"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._region) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._district) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._town) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._street) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._house) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._region {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._district {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._town {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._street {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._house {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 6)
    }
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FullAddress, rhs: FullAddress) -> Bool {
    if lhs._region != rhs._region {return false}
    if lhs._district != rhs._district {return false}
    if lhs._town != rhs._town {return false}
    if lhs._street != rhs._street {return false}
    if lhs._house != rhs._house {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CardLotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardLotRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CardLotRequest, rhs: CardLotRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CardLot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardLot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
    3: .same(proto: "photos"),
    4: .same(proto: "gender"),
    5: .same(proto: "address"),
    6: .same(proto: "parameters"),
    7: .same(proto: "description"),
    8: .same(proto: "price"),
    9: .same(proto: "favorite"),
    10: .same(proto: "own"),
    11: .standard(proto: "can_add_review"),
    12: .same(proto: "contact"),
    13: .same(proto: "seller"),
    14: .same(proto: "statistics"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64 = 0
    var _title: String = String()
    var _photos: [Photo] = []
    var _gender: Gender? = nil
    var _address: Address? = nil
    var _parameters: [Parameter] = []
    var _description_p: String = String()
    var _price: String = String()
    var _favorite: Bool = false
    var _own: Bool = false
    var _canAddReview: Bool = false
    var _contact: Contact? = nil
    var _seller: Seller? = nil
    var _statistics: Statistics? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _title = source._title
      _photos = source._photos
      _gender = source._gender
      _address = source._address
      _parameters = source._parameters
      _description_p = source._description_p
      _price = source._price
      _favorite = source._favorite
      _own = source._own
      _canAddReview = source._canAddReview
      _contact = source._contact
      _seller = source._seller
      _statistics = source._statistics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._photos) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._gender) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._address) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._parameters) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._price) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._favorite) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._own) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._canAddReview) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._contact) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._seller) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._statistics) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 2)
      }
      if !_storage._photos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._photos, fieldNumber: 3)
      }
      try { if let v = _storage._gender {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._address {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._parameters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._parameters, fieldNumber: 6)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 7)
      }
      if !_storage._price.isEmpty {
        try visitor.visitSingularStringField(value: _storage._price, fieldNumber: 8)
      }
      if _storage._favorite != false {
        try visitor.visitSingularBoolField(value: _storage._favorite, fieldNumber: 9)
      }
      if _storage._own != false {
        try visitor.visitSingularBoolField(value: _storage._own, fieldNumber: 10)
      }
      if _storage._canAddReview != false {
        try visitor.visitSingularBoolField(value: _storage._canAddReview, fieldNumber: 11)
      }
      try { if let v = _storage._contact {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._seller {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._statistics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CardLot, rhs: CardLot) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._photos != rhs_storage._photos {return false}
        if _storage._gender != rhs_storage._gender {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._parameters != rhs_storage._parameters {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._favorite != rhs_storage._favorite {return false}
        if _storage._own != rhs_storage._own {return false}
        if _storage._canAddReview != rhs_storage._canAddReview {return false}
        if _storage._contact != rhs_storage._contact {return false}
        if _storage._seller != rhs_storage._seller {return false}
        if _storage._statistics != rhs_storage._statistics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Statistics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Statistics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "view"),
    2: .same(proto: "favorite"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.view) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.favorite) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.view != 0 {
      try visitor.visitSingularInt32Field(value: self.view, fieldNumber: 1)
    }
    if self.favorite != 0 {
      try visitor.visitSingularInt32Field(value: self.favorite, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Statistics, rhs: Statistics) -> Bool {
    if lhs.view != rhs.view {return false}
    if lhs.favorite != rhs.favorite {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Seller: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Seller"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "surname"),
    4: .same(proto: "rating"),
    5: .same(proto: "online"),
    6: .standard(proto: "image_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.surname) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.rating) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.online) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.imageURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.surname.isEmpty {
      try visitor.visitSingularStringField(value: self.surname, fieldNumber: 3)
    }
    if self.rating != 0 {
      try visitor.visitSingularDoubleField(value: self.rating, fieldNumber: 4)
    }
    if self.online != false {
      try visitor.visitSingularBoolField(value: self.online, fieldNumber: 5)
    }
    if !self.imageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imageURL, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Seller, rhs: Seller) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.surname != rhs.surname {return false}
    if lhs.rating != rhs.rating {return false}
    if lhs.online != rhs.online {return false}
    if lhs.imageURL != rhs.imageURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Contact"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "communication_channel"),
    2: .standard(proto: "channel_link"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.communicationChannel) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._channelLink) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.communicationChannel.isEmpty {
      try visitor.visitPackedEnumField(value: self.communicationChannel, fieldNumber: 1)
    }
    try { if let v = self._channelLink {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Contact, rhs: Contact) -> Bool {
    if lhs.communicationChannel != rhs.communicationChannel {return false}
    if lhs._channelLink != rhs._channelLink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChannelLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelLink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "vk"),
    3: .same(proto: "email"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._phone) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._vk) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._email) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._phone {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._vk {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._email {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChannelLink, rhs: ChannelLink) -> Bool {
    if lhs._phone != rhs._phone {return false}
    if lhs._vk != rhs._vk {return false}
    if lhs._email != rhs._email {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
