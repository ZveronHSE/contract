// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: external_lot.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Ru_Zveron_Contract_Lot_TypeSort: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Сортировка по возрастанию
  case asc // = 0

  /// Сортировка по убыванию
  case desc // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .asc
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .asc
    case 1: self = .desc
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .asc: return 0
    case .desc: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ru_Zveron_Contract_Lot_TypeSort: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Ru_Zveron_Contract_Lot_TypeSort] = [
    .asc,
    .desc,
  ]
}

#endif  // swift(>=4.2)

public enum Ru_Zveron_Contract_Lot_Field: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case price // = 0

  /// Тип объявления
  case lotFormID // = 1

  /// Когда создано объявление
  case dateCreation // = 2

  /// Гендер у объявления, если продают животного.
  case gender // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .price
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .price
    case 1: self = .lotFormID
    case 2: self = .dateCreation
    case 3: self = .gender
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .price: return 0
    case .lotFormID: return 1
    case .dateCreation: return 2
    case .gender: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ru_Zveron_Contract_Lot_Field: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Ru_Zveron_Contract_Lot_Field] = [
    .price,
    .lotFormID,
    .dateCreation,
    .gender,
  ]
}

#endif  // swift(>=4.2)

public enum Ru_Zveron_Contract_Lot_Operation: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Поле равно значению.
  case equality // = 0

  /// Поле не равно значению.
  case negation // = 1

  /// Поле больше, чем
  case greaterThan // = 2

  /// Поле больше или равно значению.
  case greaterThanEquality // = 3

  /// Поле меньше, чем значение.
  case lessThan // = 4

  /// Поле меньше или равно значению.
  case lessThanEquality // = 5

  /// Поле входит в несколько значений, значения передаются через запятую, например: price==15,346,765,8794
  case `in` // = 6

  /// Поле не входит в несколько значений, значения передаются через запятую, например: price==15,346,765,8794
  case notIn // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .equality
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .equality
    case 1: self = .negation
    case 2: self = .greaterThan
    case 3: self = .greaterThanEquality
    case 4: self = .lessThan
    case 5: self = .lessThanEquality
    case 6: self = .in
    case 7: self = .notIn
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .equality: return 0
    case .negation: return 1
    case .greaterThan: return 2
    case .greaterThanEquality: return 3
    case .lessThan: return 4
    case .lessThanEquality: return 5
    case .in: return 6
    case .notIn: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ru_Zveron_Contract_Lot_Operation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Ru_Zveron_Contract_Lot_Operation] = [
    .equality,
    .negation,
    .greaterThan,
    .greaterThanEquality,
    .lessThan,
    .lessThanEquality,
    .in,
    .notIn,
  ]
}

#endif  // swift(>=4.2)

public enum Ru_Zveron_Contract_Lot_ClosingLotReason: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Продал на этом сайте
  case sold // = 0

  /// Продал в другом месте
  case soldSomewhere // = 1

  /// Продажа неактуальна
  case irrelevant // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .sold
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sold
    case 1: self = .soldSomewhere
    case 2: self = .irrelevant
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .sold: return 0
    case .soldSomewhere: return 1
    case .irrelevant: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ru_Zveron_Contract_Lot_ClosingLotReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Ru_Zveron_Contract_Lot_ClosingLotReason] = [
    .sold,
    .soldSomewhere,
    .irrelevant,
  ]
}

#endif  // swift(>=4.2)

public struct Ru_Zveron_Contract_Lot_WaterfallRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Количество элементов запрашиваемых на страницу
  public var pageSize: Int32 = 0

  /// По какому слову искать в объявлениях, например, по "собака"
  public var query: String {
    get {return _query ?? String()}
    set {_query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  public var hasQuery: Bool {return self._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  public mutating func clearQuery() {self._query = nil}

  /// По какому категорию отбирать объявления (учитываются и все дочерние категории)
  public var categoryID: Int32 {
    get {return _categoryID ?? 0}
    set {_categoryID = newValue}
  }
  /// Returns true if `categoryID` has been explicitly set.
  public var hasCategoryID: Bool {return self._categoryID != nil}
  /// Clears the value of `categoryID`. Subsequent reads from it will return its default value.
  public mutating func clearCategoryID() {self._categoryID = nil}

  /// Фильтровать по различным полям объявления, кроме параметров. (например, цена, дата и тд)
  public var filters: [Ru_Zveron_Contract_Lot_Filter] = []

  /// Фильтровать по параметрам объявления, если они заданы
  public var parameters: [Ru_Zveron_Contract_Lot_Model_Parameter] = []

  /// По какому признаку нужно сортировать объявления
  public var sort: Ru_Zveron_Contract_Lot_WaterfallRequest.OneOf_Sort? = nil

  public var sortByDate: Ru_Zveron_Contract_Lot_SortByDate {
    get {
      if case .sortByDate(let v)? = sort {return v}
      return Ru_Zveron_Contract_Lot_SortByDate()
    }
    set {sort = .sortByDate(newValue)}
  }

  public var sortByPrice: Ru_Zveron_Contract_Lot_SortByPrice {
    get {
      if case .sortByPrice(let v)? = sort {return v}
      return Ru_Zveron_Contract_Lot_SortByPrice()
    }
    set {sort = .sortByPrice(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// По какому признаку нужно сортировать объявления
  public enum OneOf_Sort: Equatable {
    case sortByDate(Ru_Zveron_Contract_Lot_SortByDate)
    case sortByPrice(Ru_Zveron_Contract_Lot_SortByPrice)

  #if !swift(>=4.1)
    public static func ==(lhs: Ru_Zveron_Contract_Lot_WaterfallRequest.OneOf_Sort, rhs: Ru_Zveron_Contract_Lot_WaterfallRequest.OneOf_Sort) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sortByDate, .sortByDate): return {
        guard case .sortByDate(let l) = lhs, case .sortByDate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sortByPrice, .sortByPrice): return {
        guard case .sortByPrice(let l) = lhs, case .sortByPrice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _query: String? = nil
  fileprivate var _categoryID: Int32? = nil
}

public struct Ru_Zveron_Contract_Lot_SortByDate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var typeSort: Ru_Zveron_Contract_Lot_TypeSort = .asc

  public var lastLot: Ru_Zveron_Contract_Lot_SortByDate.LastLot {
    get {return _lastLot ?? Ru_Zveron_Contract_Lot_SortByDate.LastLot()}
    set {_lastLot = newValue}
  }
  /// Returns true if `lastLot` has been explicitly set.
  public var hasLastLot: Bool {return self._lastLot != nil}
  /// Clears the value of `lastLot`. Subsequent reads from it will return its default value.
  public mutating func clearLastLot() {self._lastLot = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Данные последнего объявления, который был на прошлой странице(если запрос от второй страницы и последующей)
  public struct LastLot {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: Int64 = 0

    /// Дата создания
    public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_date = newValue}
    }
    /// Returns true if `date` has been explicitly set.
    public var hasDate: Bool {return self._date != nil}
    /// Clears the value of `date`. Subsequent reads from it will return its default value.
    public mutating func clearDate() {self._date = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public init() {}

  fileprivate var _lastLot: Ru_Zveron_Contract_Lot_SortByDate.LastLot? = nil
}

public struct Ru_Zveron_Contract_Lot_SortByPrice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var typeSort: Ru_Zveron_Contract_Lot_TypeSort = .asc

  public var lastLot: Ru_Zveron_Contract_Lot_SortByPrice.LastLot {
    get {return _lastLot ?? Ru_Zveron_Contract_Lot_SortByPrice.LastLot()}
    set {_lastLot = newValue}
  }
  /// Returns true if `lastLot` has been explicitly set.
  public var hasLastLot: Bool {return self._lastLot != nil}
  /// Clears the value of `lastLot`. Subsequent reads from it will return its default value.
  public mutating func clearLastLot() {self._lastLot = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Данные последнего объявления, который был на прошлой странице(если запрос от второй страницы и последующей)
  public struct LastLot {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: Int64 = 0

    public var price: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _lastLot: Ru_Zveron_Contract_Lot_SortByPrice.LastLot? = nil
}

public struct Ru_Zveron_Contract_Lot_Filter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field: Ru_Zveron_Contract_Lot_Field = .price

  public var operation: Ru_Zveron_Contract_Lot_Operation = .equality

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ru_Zveron_Contract_Lot_WaterfallResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lots: [Ru_Zveron_Contract_Lot_WaterfallLot] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ru_Zveron_Contract_Lot_WaterfallLot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lot: Ru_Zveron_Contract_Lot_Model_Lot {
    get {return _lot ?? Ru_Zveron_Contract_Lot_Model_Lot()}
    set {_lot = newValue}
  }
  /// Returns true if `lot` has been explicitly set.
  public var hasLot: Bool {return self._lot != nil}
  /// Clears the value of `lot`. Subsequent reads from it will return its default value.
  public mutating func clearLot() {self._lot = nil}

  /// Данные последнего объявления, необходимые для сортировки и работы водопада
  public var dataFilter: Ru_Zveron_Contract_Lot_DataFilter {
    get {return _dataFilter ?? Ru_Zveron_Contract_Lot_DataFilter()}
    set {_dataFilter = newValue}
  }
  /// Returns true if `dataFilter` has been explicitly set.
  public var hasDataFilter: Bool {return self._dataFilter != nil}
  /// Clears the value of `dataFilter`. Subsequent reads from it will return its default value.
  public mutating func clearDataFilter() {self._dataFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lot: Ru_Zveron_Contract_Lot_Model_Lot? = nil
  fileprivate var _dataFilter: Ru_Zveron_Contract_Lot_DataFilter? = nil
}

public struct Ru_Zveron_Contract_Lot_DataFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var price: Int32 = 0

  /// Пока тут не уверена по типу
  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Ru_Zveron_Contract_Lot_CreateLotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var photos: [Ru_Zveron_Contract_Lot_Model_Photo] = []

  /// Заданные параметры объявления
  public var parameters: [Ru_Zveron_Contract_Lot_Model_Parameter] = []

  public var description_p: String = String()

  public var price: String = String()

  /// Количество выбранных связей, их может быть 1 или 2.
  public var communicationChannel: [Ru_Zveron_Contract_Lot_Model_CommunicationChannel] = []

  /// Это может отсутствовать, если гендера нет для объявления, например, для товаров.
  public var gender: Ru_Zveron_Contract_Lot_Model_Gender {
    get {return _gender ?? .female}
    set {_gender = newValue}
  }
  /// Returns true if `gender` has been explicitly set.
  public var hasGender: Bool {return self._gender != nil}
  /// Clears the value of `gender`. Subsequent reads from it will return its default value.
  public mutating func clearGender() {self._gender = nil}

  public var address: Ru_Zveron_Contract_Lot_FullAddress {
    get {return _address ?? Ru_Zveron_Contract_Lot_FullAddress()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {self._address = nil}

  public var lotFormID: Int32 = 0

  public var categoryID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _gender: Ru_Zveron_Contract_Lot_Model_Gender? = nil
  fileprivate var _address: Ru_Zveron_Contract_Lot_FullAddress? = nil
}

/// Path /api/lot/edit, ответ будет в виде CardLot
public struct Ru_Zveron_Contract_Lot_EditLotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID объявления
  public var id: Int64 = 0

  public var title: String = String()

  public var photos: [Ru_Zveron_Contract_Lot_Model_Photo] = []

  /// Заданные параметры объявления
  public var parameters: [Ru_Zveron_Contract_Lot_Model_Parameter] = []

  public var description_p: String = String()

  public var price: String = String()

  /// Количество выбранных связей, их может быть 1 или 2.
  public var communicationChannel: [Ru_Zveron_Contract_Lot_Model_CommunicationChannel] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Path /api/lot/close, ответ будет пустым
public struct Ru_Zveron_Contract_Lot_CloseLotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID объявления
  public var id: Int64 = 0

  public var closingLotReason: Ru_Zveron_Contract_Lot_ClosingLotReason = .sold

  /// Идентификатор покупателя, если объявление было продано на этом сайте
  public var customerID: Int64 {
    get {return _customerID ?? 0}
    set {_customerID = newValue}
  }
  /// Returns true if `customerID` has been explicitly set.
  public var hasCustomerID: Bool {return self._customerID != nil}
  /// Clears the value of `customerID`. Subsequent reads from it will return its default value.
  public mutating func clearCustomerID() {self._customerID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _customerID: Int64? = nil
}

public struct Ru_Zveron_Contract_Lot_FullAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var region: String {
    get {return _region ?? String()}
    set {_region = newValue}
  }
  /// Returns true if `region` has been explicitly set.
  public var hasRegion: Bool {return self._region != nil}
  /// Clears the value of `region`. Subsequent reads from it will return its default value.
  public mutating func clearRegion() {self._region = nil}

  public var district: String {
    get {return _district ?? String()}
    set {_district = newValue}
  }
  /// Returns true if `district` has been explicitly set.
  public var hasDistrict: Bool {return self._district != nil}
  /// Clears the value of `district`. Subsequent reads from it will return its default value.
  public mutating func clearDistrict() {self._district = nil}

  public var town: String {
    get {return _town ?? String()}
    set {_town = newValue}
  }
  /// Returns true if `town` has been explicitly set.
  public var hasTown: Bool {return self._town != nil}
  /// Clears the value of `town`. Subsequent reads from it will return its default value.
  public mutating func clearTown() {self._town = nil}

  public var street: String {
    get {return _street ?? String()}
    set {_street = newValue}
  }
  /// Returns true if `street` has been explicitly set.
  public var hasStreet: Bool {return self._street != nil}
  /// Clears the value of `street`. Subsequent reads from it will return its default value.
  public mutating func clearStreet() {self._street = nil}

  public var house: String {
    get {return _house ?? String()}
    set {_house = newValue}
  }
  /// Returns true if `house` has been explicitly set.
  public var hasHouse: Bool {return self._house != nil}
  /// Clears the value of `house`. Subsequent reads from it will return its default value.
  public mutating func clearHouse() {self._house = nil}

  public var longitude: Double = 0

  public var latitude: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _region: String? = nil
  fileprivate var _district: String? = nil
  fileprivate var _town: String? = nil
  fileprivate var _street: String? = nil
  fileprivate var _house: String? = nil
}

public struct Ru_Zveron_Contract_Lot_CardLotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID объявления
  public var id: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ru_Zveron_Contract_Lot_CardLot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID объявления
  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  public var photos: [Ru_Zveron_Contract_Lot_Model_Photo] {
    get {return _storage._photos}
    set {_uniqueStorage()._photos = newValue}
  }

  /// Это может отсутствовать, если гендера нет для объявления, например, для товаров.
  public var gender: Ru_Zveron_Contract_Lot_Model_Gender {
    get {return _storage._gender ?? .female}
    set {_uniqueStorage()._gender = newValue}
  }
  /// Returns true if `gender` has been explicitly set.
  public var hasGender: Bool {return _storage._gender != nil}
  /// Clears the value of `gender`. Subsequent reads from it will return its default value.
  public mutating func clearGender() {_uniqueStorage()._gender = nil}

  public var address: Ru_Zveron_Contract_Lot_Model_Address {
    get {return _storage._address ?? Ru_Zveron_Contract_Lot_Model_Address()}
    set {_uniqueStorage()._address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return _storage._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {_uniqueStorage()._address = nil}

  /// Заданные параметры объявления
  public var parameters: [Ru_Zveron_Contract_Lot_Model_Parameter] {
    get {return _storage._parameters}
    set {_uniqueStorage()._parameters = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// Если цены нет, то придет текст, например "Договорная", а если есть цена - то число. Этим и обусловен выбор string тут.
  public var price: String {
    get {return _storage._price}
    set {_uniqueStorage()._price = newValue}
  }

  /// Красить кнопку "Избранное", если оно уже и так добавлено в избранное, иначе нет.
  public var favorite: Bool {
    get {return _storage._favorite}
    set {_uniqueStorage()._favorite = newValue}
  }

  /// Является ли это объявление собственным, и если да, то нужно будет скрыть кнопку "Избранное" и отображать кнопку "Редактировать".
  public var own: Bool {
    get {return _storage._own}
    set {_uniqueStorage()._own = newValue}
  }

  /// Может ли пользователь добавлять отзыв на это объявление, если да, то отображать кнопку.
  public var canAddReview: Bool {
    get {return _storage._canAddReview}
    set {_uniqueStorage()._canAddReview = newValue}
  }

  public var contact: Ru_Zveron_Contract_Lot_Contact {
    get {return _storage._contact ?? Ru_Zveron_Contract_Lot_Contact()}
    set {_uniqueStorage()._contact = newValue}
  }
  /// Returns true if `contact` has been explicitly set.
  public var hasContact: Bool {return _storage._contact != nil}
  /// Clears the value of `contact`. Subsequent reads from it will return its default value.
  public mutating func clearContact() {_uniqueStorage()._contact = nil}

  public var seller: Ru_Zveron_Contract_Lot_Seller {
    get {return _storage._seller ?? Ru_Zveron_Contract_Lot_Seller()}
    set {_uniqueStorage()._seller = newValue}
  }
  /// Returns true if `seller` has been explicitly set.
  public var hasSeller: Bool {return _storage._seller != nil}
  /// Clears the value of `seller`. Subsequent reads from it will return its default value.
  public mutating func clearSeller() {_uniqueStorage()._seller = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Статистика объявления
public struct Ru_Zveron_Contract_Lot_Statistics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Количество просмотров
  public var view: Int32 = 0

  /// Количество добавленных в избранное
  public var favorite: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ru_Zveron_Contract_Lot_Seller {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  public var name: String = String()

  public var surname: String = String()

  /// Рейтинг продавца
  public var rating: Double = 0

  /// Если сейчас продавец в онлайне, то придет пустая строка, иначе форматированная дата.
  public var dateOnline: String {
    get {return _dateOnline ?? String()}
    set {_dateOnline = newValue}
  }
  /// Returns true if `dateOnline` has been explicitly set.
  public var hasDateOnline: Bool {return self._dateOnline != nil}
  /// Clears the value of `dateOnline`. Subsequent reads from it will return its default value.
  public mutating func clearDateOnline() {self._dateOnline = nil}

  public var photo: Ru_Zveron_Contract_Lot_Model_Photo {
    get {return _photo ?? Ru_Zveron_Contract_Lot_Model_Photo()}
    set {_photo = newValue}
  }
  /// Returns true if `photo` has been explicitly set.
  public var hasPhoto: Bool {return self._photo != nil}
  /// Clears the value of `photo`. Subsequent reads from it will return its default value.
  public mutating func clearPhoto() {self._photo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dateOnline: String? = nil
  fileprivate var _photo: Ru_Zveron_Contract_Lot_Model_Photo? = nil
}

public struct Ru_Zveron_Contract_Lot_Contact {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Какие способы связи были выбраны.
  public var communicationChannel: [Ru_Zveron_Contract_Lot_Model_CommunicationChannel] = []

  /// Ссылки для выбранных способов связи.
  public var channelLink: Ru_Zveron_Contract_Lot_ChannelLink {
    get {return _channelLink ?? Ru_Zveron_Contract_Lot_ChannelLink()}
    set {_channelLink = newValue}
  }
  /// Returns true if `channelLink` has been explicitly set.
  public var hasChannelLink: Bool {return self._channelLink != nil}
  /// Clears the value of `channelLink`. Subsequent reads from it will return its default value.
  public mutating func clearChannelLink() {self._channelLink = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _channelLink: Ru_Zveron_Contract_Lot_ChannelLink? = nil
}

/// Отображается информация про тех или иных способах только в тех случаях, когда они были выбраны в CommunicationChannel
public struct Ru_Zveron_Contract_Lot_ChannelLink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Номер телефона в формате +79994443322
  public var phone: String {
    get {return _phone ?? String()}
    set {_phone = newValue}
  }
  /// Returns true if `phone` has been explicitly set.
  public var hasPhone: Bool {return self._phone != nil}
  /// Clears the value of `phone`. Subsequent reads from it will return its default value.
  public mutating func clearPhone() {self._phone = nil}

  /// Ссылка на профиль в ВК
  public var vk: String {
    get {return _vk ?? String()}
    set {_vk = newValue}
  }
  /// Returns true if `vk` has been explicitly set.
  public var hasVk: Bool {return self._vk != nil}
  /// Clears the value of `vk`. Subsequent reads from it will return its default value.
  public mutating func clearVk() {self._vk = nil}

  /// Ссылка на почту для создания письма (emailto:..)
  public var email: String {
    get {return _email ?? String()}
    set {_email = newValue}
  }
  /// Returns true if `email` has been explicitly set.
  public var hasEmail: Bool {return self._email != nil}
  /// Clears the value of `email`. Subsequent reads from it will return its default value.
  public mutating func clearEmail() {self._email = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _phone: String? = nil
  fileprivate var _vk: String? = nil
  fileprivate var _email: String? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Ru_Zveron_Contract_Lot_TypeSort: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_Field: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_Operation: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_ClosingLotReason: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_WaterfallRequest: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_WaterfallRequest.OneOf_Sort: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_SortByDate: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_SortByDate.LastLot: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_SortByPrice: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_SortByPrice.LastLot: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_Filter: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_WaterfallResponse: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_WaterfallLot: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_DataFilter: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_CreateLotRequest: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_EditLotRequest: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_CloseLotRequest: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_FullAddress: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_CardLotRequest: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_CardLot: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_Statistics: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_Seller: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_Contact: @unchecked Sendable {}
extension Ru_Zveron_Contract_Lot_ChannelLink: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ru.zveron.contract.lot"

extension Ru_Zveron_Contract_Lot_TypeSort: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ASC"),
    1: .same(proto: "DESC"),
  ]
}

extension Ru_Zveron_Contract_Lot_Field: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRICE"),
    1: .same(proto: "LOT_FORM_ID"),
    2: .same(proto: "DATE_CREATION"),
    3: .same(proto: "GENDER"),
  ]
}

extension Ru_Zveron_Contract_Lot_Operation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EQUALITY"),
    1: .same(proto: "NEGATION"),
    2: .same(proto: "GREATER_THAN"),
    3: .same(proto: "GREATER_THAN_EQUALITY"),
    4: .same(proto: "LESS_THAN"),
    5: .same(proto: "LESS_THAN_EQUALITY"),
    6: .same(proto: "IN"),
    7: .same(proto: "NOT_IN"),
  ]
}

extension Ru_Zveron_Contract_Lot_ClosingLotReason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOLD"),
    1: .same(proto: "SOLD_SOMEWHERE"),
    2: .same(proto: "IRRELEVANT"),
  ]
}

extension Ru_Zveron_Contract_Lot_WaterfallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaterfallRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_size"),
    2: .same(proto: "query"),
    3: .standard(proto: "category_id"),
    4: .same(proto: "filters"),
    5: .same(proto: "parameters"),
    6: .standard(proto: "sort_by_date"),
    7: .standard(proto: "sort_by_price"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._query) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._categoryID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.parameters) }()
      case 6: try {
        var v: Ru_Zveron_Contract_Lot_SortByDate?
        var hadOneofValue = false
        if let current = self.sort {
          hadOneofValue = true
          if case .sortByDate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sort = .sortByDate(v)
        }
      }()
      case 7: try {
        var v: Ru_Zveron_Contract_Lot_SortByPrice?
        var hadOneofValue = false
        if let current = self.sort {
          hadOneofValue = true
          if case .sortByPrice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sort = .sortByPrice(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    try { if let v = self._query {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._categoryID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 4)
    }
    if !self.parameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameters, fieldNumber: 5)
    }
    switch self.sort {
    case .sortByDate?: try {
      guard case .sortByDate(let v)? = self.sort else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .sortByPrice?: try {
      guard case .sortByPrice(let v)? = self.sort else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ru_Zveron_Contract_Lot_WaterfallRequest, rhs: Ru_Zveron_Contract_Lot_WaterfallRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs._query != rhs._query {return false}
    if lhs._categoryID != rhs._categoryID {return false}
    if lhs.filters != rhs.filters {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.sort != rhs.sort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Zveron_Contract_Lot_SortByDate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SortByDate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "type_sort"),
    2: .standard(proto: "last_lot"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.typeSort) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lastLot) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.typeSort != .asc {
      try visitor.visitSingularEnumField(value: self.typeSort, fieldNumber: 1)
    }
    try { if let v = self._lastLot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ru_Zveron_Contract_Lot_SortByDate, rhs: Ru_Zveron_Contract_Lot_SortByDate) -> Bool {
    if lhs.typeSort != rhs.typeSort {return false}
    if lhs._lastLot != rhs._lastLot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Zveron_Contract_Lot_SortByDate.LastLot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Ru_Zveron_Contract_Lot_SortByDate.protoMessageName + ".LastLot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ru_Zveron_Contract_Lot_SortByDate.LastLot, rhs: Ru_Zveron_Contract_Lot_SortByDate.LastLot) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._date != rhs._date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Zveron_Contract_Lot_SortByPrice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SortByPrice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "type_sort"),
    2: .standard(proto: "last_lot"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.typeSort) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lastLot) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.typeSort != .asc {
      try visitor.visitSingularEnumField(value: self.typeSort, fieldNumber: 1)
    }
    try { if let v = self._lastLot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ru_Zveron_Contract_Lot_SortByPrice, rhs: Ru_Zveron_Contract_Lot_SortByPrice) -> Bool {
    if lhs.typeSort != rhs.typeSort {return false}
    if lhs._lastLot != rhs._lastLot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Zveron_Contract_Lot_SortByPrice.LastLot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Ru_Zveron_Contract_Lot_SortByPrice.protoMessageName + ".LastLot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "price"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.price) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.price != 0 {
      try visitor.visitSingularInt32Field(value: self.price, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ru_Zveron_Contract_Lot_SortByPrice.LastLot, rhs: Ru_Zveron_Contract_Lot_SortByPrice.LastLot) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.price != rhs.price {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Zveron_Contract_Lot_Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .same(proto: "operation"),
    3: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.field) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.field != .price {
      try visitor.visitSingularEnumField(value: self.field, fieldNumber: 1)
    }
    if self.operation != .equality {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ru_Zveron_Contract_Lot_Filter, rhs: Ru_Zveron_Contract_Lot_Filter) -> Bool {
    if lhs.field != rhs.field {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Zveron_Contract_Lot_WaterfallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaterfallResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lots"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.lots) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lots.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lots, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ru_Zveron_Contract_Lot_WaterfallResponse, rhs: Ru_Zveron_Contract_Lot_WaterfallResponse) -> Bool {
    if lhs.lots != rhs.lots {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Zveron_Contract_Lot_WaterfallLot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaterfallLot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lot"),
    2: .standard(proto: "data_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lot) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dataFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dataFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ru_Zveron_Contract_Lot_WaterfallLot, rhs: Ru_Zveron_Contract_Lot_WaterfallLot) -> Bool {
    if lhs._lot != rhs._lot {return false}
    if lhs._dataFilter != rhs._dataFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Zveron_Contract_Lot_DataFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.price) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.price != 0 {
      try visitor.visitSingularInt32Field(value: self.price, fieldNumber: 1)
    }
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ru_Zveron_Contract_Lot_DataFilter, rhs: Ru_Zveron_Contract_Lot_DataFilter) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs._date != rhs._date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Zveron_Contract_Lot_CreateLotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateLotRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "photos"),
    3: .same(proto: "parameters"),
    4: .same(proto: "description"),
    5: .same(proto: "price"),
    6: .standard(proto: "communication_channel"),
    7: .same(proto: "gender"),
    8: .same(proto: "address"),
    9: .standard(proto: "lot_form_id"),
    10: .standard(proto: "category_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.photos) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.parameters) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 6: try { try decoder.decodeRepeatedEnumField(value: &self.communicationChannel) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._gender) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.lotFormID) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.categoryID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.photos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.photos, fieldNumber: 2)
    }
    if !self.parameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameters, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 5)
    }
    if !self.communicationChannel.isEmpty {
      try visitor.visitPackedEnumField(value: self.communicationChannel, fieldNumber: 6)
    }
    try { if let v = self._gender {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.lotFormID != 0 {
      try visitor.visitSingularInt32Field(value: self.lotFormID, fieldNumber: 9)
    }
    if self.categoryID != 0 {
      try visitor.visitSingularInt32Field(value: self.categoryID, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ru_Zveron_Contract_Lot_CreateLotRequest, rhs: Ru_Zveron_Contract_Lot_CreateLotRequest) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.photos != rhs.photos {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.price != rhs.price {return false}
    if lhs.communicationChannel != rhs.communicationChannel {return false}
    if lhs._gender != rhs._gender {return false}
    if lhs._address != rhs._address {return false}
    if lhs.lotFormID != rhs.lotFormID {return false}
    if lhs.categoryID != rhs.categoryID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Zveron_Contract_Lot_EditLotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditLotRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
    3: .same(proto: "photos"),
    4: .same(proto: "parameters"),
    5: .same(proto: "description"),
    6: .same(proto: "price"),
    7: .standard(proto: "communication_channel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.photos) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.parameters) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.price) }()
      case 7: try { try decoder.decodeRepeatedEnumField(value: &self.communicationChannel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.photos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.photos, fieldNumber: 3)
    }
    if !self.parameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameters, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 6)
    }
    if !self.communicationChannel.isEmpty {
      try visitor.visitPackedEnumField(value: self.communicationChannel, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ru_Zveron_Contract_Lot_EditLotRequest, rhs: Ru_Zveron_Contract_Lot_EditLotRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.photos != rhs.photos {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.price != rhs.price {return false}
    if lhs.communicationChannel != rhs.communicationChannel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Zveron_Contract_Lot_CloseLotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloseLotRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "closing_lot_reason"),
    3: .standard(proto: "customer_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.closingLotReason) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._customerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.closingLotReason != .sold {
      try visitor.visitSingularEnumField(value: self.closingLotReason, fieldNumber: 2)
    }
    try { if let v = self._customerID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ru_Zveron_Contract_Lot_CloseLotRequest, rhs: Ru_Zveron_Contract_Lot_CloseLotRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.closingLotReason != rhs.closingLotReason {return false}
    if lhs._customerID != rhs._customerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Zveron_Contract_Lot_FullAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FullAddress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "region"),
    2: .same(proto: "district"),
    3: .same(proto: "town"),
    4: .same(proto: "street"),
    5: .same(proto: "house"),
    6: .same(proto: "longitude"),
    7: .same(proto: "latitude"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._region) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._district) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._town) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._street) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._house) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._region {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._district {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._town {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._street {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._house {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 6)
    }
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ru_Zveron_Contract_Lot_FullAddress, rhs: Ru_Zveron_Contract_Lot_FullAddress) -> Bool {
    if lhs._region != rhs._region {return false}
    if lhs._district != rhs._district {return false}
    if lhs._town != rhs._town {return false}
    if lhs._street != rhs._street {return false}
    if lhs._house != rhs._house {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Zveron_Contract_Lot_CardLotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardLotRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ru_Zveron_Contract_Lot_CardLotRequest, rhs: Ru_Zveron_Contract_Lot_CardLotRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Zveron_Contract_Lot_CardLot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardLot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
    3: .same(proto: "photos"),
    4: .same(proto: "gender"),
    5: .same(proto: "address"),
    6: .same(proto: "parameters"),
    7: .same(proto: "description"),
    8: .same(proto: "price"),
    9: .same(proto: "favorite"),
    10: .same(proto: "own"),
    11: .standard(proto: "can_add_review"),
    12: .same(proto: "contact"),
    13: .same(proto: "seller"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64 = 0
    var _title: String = String()
    var _photos: [Ru_Zveron_Contract_Lot_Model_Photo] = []
    var _gender: Ru_Zveron_Contract_Lot_Model_Gender? = nil
    var _address: Ru_Zveron_Contract_Lot_Model_Address? = nil
    var _parameters: [Ru_Zveron_Contract_Lot_Model_Parameter] = []
    var _description_p: String = String()
    var _price: String = String()
    var _favorite: Bool = false
    var _own: Bool = false
    var _canAddReview: Bool = false
    var _contact: Ru_Zveron_Contract_Lot_Contact? = nil
    var _seller: Ru_Zveron_Contract_Lot_Seller? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _title = source._title
      _photos = source._photos
      _gender = source._gender
      _address = source._address
      _parameters = source._parameters
      _description_p = source._description_p
      _price = source._price
      _favorite = source._favorite
      _own = source._own
      _canAddReview = source._canAddReview
      _contact = source._contact
      _seller = source._seller
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._photos) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._gender) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._address) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._parameters) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._price) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._favorite) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._own) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._canAddReview) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._contact) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._seller) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 2)
      }
      if !_storage._photos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._photos, fieldNumber: 3)
      }
      try { if let v = _storage._gender {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._address {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._parameters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._parameters, fieldNumber: 6)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 7)
      }
      if !_storage._price.isEmpty {
        try visitor.visitSingularStringField(value: _storage._price, fieldNumber: 8)
      }
      if _storage._favorite != false {
        try visitor.visitSingularBoolField(value: _storage._favorite, fieldNumber: 9)
      }
      if _storage._own != false {
        try visitor.visitSingularBoolField(value: _storage._own, fieldNumber: 10)
      }
      if _storage._canAddReview != false {
        try visitor.visitSingularBoolField(value: _storage._canAddReview, fieldNumber: 11)
      }
      try { if let v = _storage._contact {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._seller {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ru_Zveron_Contract_Lot_CardLot, rhs: Ru_Zveron_Contract_Lot_CardLot) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._photos != rhs_storage._photos {return false}
        if _storage._gender != rhs_storage._gender {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._parameters != rhs_storage._parameters {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._favorite != rhs_storage._favorite {return false}
        if _storage._own != rhs_storage._own {return false}
        if _storage._canAddReview != rhs_storage._canAddReview {return false}
        if _storage._contact != rhs_storage._contact {return false}
        if _storage._seller != rhs_storage._seller {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Zveron_Contract_Lot_Statistics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Statistics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "view"),
    2: .same(proto: "favorite"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.view) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.favorite) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.view != 0 {
      try visitor.visitSingularInt32Field(value: self.view, fieldNumber: 1)
    }
    if self.favorite != 0 {
      try visitor.visitSingularInt32Field(value: self.favorite, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ru_Zveron_Contract_Lot_Statistics, rhs: Ru_Zveron_Contract_Lot_Statistics) -> Bool {
    if lhs.view != rhs.view {return false}
    if lhs.favorite != rhs.favorite {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Zveron_Contract_Lot_Seller: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Seller"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "surname"),
    4: .same(proto: "rating"),
    5: .standard(proto: "date_online"),
    6: .same(proto: "photo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.surname) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.rating) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._dateOnline) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._photo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.surname.isEmpty {
      try visitor.visitSingularStringField(value: self.surname, fieldNumber: 3)
    }
    if self.rating != 0 {
      try visitor.visitSingularDoubleField(value: self.rating, fieldNumber: 4)
    }
    try { if let v = self._dateOnline {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._photo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ru_Zveron_Contract_Lot_Seller, rhs: Ru_Zveron_Contract_Lot_Seller) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.surname != rhs.surname {return false}
    if lhs.rating != rhs.rating {return false}
    if lhs._dateOnline != rhs._dateOnline {return false}
    if lhs._photo != rhs._photo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Zveron_Contract_Lot_Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Contact"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "communication_channel"),
    2: .standard(proto: "channel_link"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.communicationChannel) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._channelLink) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.communicationChannel.isEmpty {
      try visitor.visitPackedEnumField(value: self.communicationChannel, fieldNumber: 1)
    }
    try { if let v = self._channelLink {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ru_Zveron_Contract_Lot_Contact, rhs: Ru_Zveron_Contract_Lot_Contact) -> Bool {
    if lhs.communicationChannel != rhs.communicationChannel {return false}
    if lhs._channelLink != rhs._channelLink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ru_Zveron_Contract_Lot_ChannelLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelLink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "vk"),
    3: .same(proto: "email"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._phone) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._vk) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._email) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._phone {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._vk {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._email {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ru_Zveron_Contract_Lot_ChannelLink, rhs: Ru_Zveron_Contract_Lot_ChannelLink) -> Bool {
    if lhs._phone != rhs._phone {return false}
    if lhs._vk != rhs._vk {return false}
    if lhs._email != rhs._email {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
