// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: profile_external.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct GetProfilePageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestedProfileID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SetProfileInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var surname: String {
    get {return _surname ?? String()}
    set {_surname = newValue}
  }
  /// Returns true if `surname` has been explicitly set.
  public var hasSurname: Bool {return self._surname != nil}
  /// Clears the value of `surname`. Subsequent reads from it will return its default value.
  public mutating func clearSurname() {self._surname = nil}

  public var imageID: UInt64 {
    get {return _imageID ?? 0}
    set {_imageID = newValue}
  }
  /// Returns true if `imageID` has been explicitly set.
  public var hasImageID: Bool {return self._imageID != nil}
  /// Clears the value of `imageID`. Subsequent reads from it will return its default value.
  public mutating func clearImageID() {self._imageID = nil}

  public var address: Address {
    get {return _address ?? Address()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {self._address = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _surname: String? = nil
  fileprivate var _imageID: UInt64? = nil
  fileprivate var _address: Address? = nil
}

public struct SetSettingsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional too
  public var channels: [ChannelType] = []

  public var address: Address {
    get {return _address ?? Address()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {self._address = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _address: Address? = nil
}

public struct GetProfileInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var name: String = String()

  public var surname: String = String()

  public var imageID: UInt64 = 0

  public var rating: Double = 0

  public var address: Address {
    get {return _address ?? Address()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {self._address = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _address: Address? = nil
}

public struct GetProfilePageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var surname: String {
    get {return _storage._surname}
    set {_uniqueStorage()._surname = newValue}
  }

  public var imageID: UInt64 {
    get {return _storage._imageID}
    set {_uniqueStorage()._imageID = newValue}
  }

  public var contacts: Contacts {
    get {return _storage._contacts ?? Contacts()}
    set {_uniqueStorage()._contacts = newValue}
  }
  /// Returns true if `contacts` has been explicitly set.
  public var hasContacts: Bool {return _storage._contacts != nil}
  /// Clears the value of `contacts`. Subsequent reads from it will return its default value.
  public mutating func clearContacts() {_uniqueStorage()._contacts = nil}

  public var rating: Double {
    get {return _storage._rating}
    set {_uniqueStorage()._rating = newValue}
  }

  public var reviewNumber: Int32 {
    get {return _storage._reviewNumber}
    set {_uniqueStorage()._reviewNumber = newValue}
  }

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var activeLots: [Lot] {
    get {return _storage._activeLots}
    set {_uniqueStorage()._activeLots = newValue}
  }

  public var closedLots: [Lot] {
    get {return _storage._closedLots}
    set {_uniqueStorage()._closedLots = newValue}
  }

  public var lastActivity: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastActivity ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastActivity = newValue}
  }
  /// Returns true if `lastActivity` has been explicitly set.
  public var hasLastActivity: Bool {return _storage._lastActivity != nil}
  /// Clears the value of `lastActivity`. Subsequent reads from it will return its default value.
  public mutating func clearLastActivity() {_uniqueStorage()._lastActivity = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct GetChannelTypesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channels: [ChannelType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Address {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var region: String = String()

  public var town: String = String()

  public var longitude: Double = 0

  public var latitude: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetSettingsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channels: [ChannelType] = []

  public var address: Address {
    get {return _address ?? Address()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {self._address = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _address: Address? = nil
}

public struct Contacts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channels: [ChannelType] = []

  public var links: Links {
    get {return _links ?? Links()}
    set {_links = newValue}
  }
  /// Returns true if `links` has been explicitly set.
  public var hasLinks: Bool {return self._links != nil}
  /// Clears the value of `links`. Subsequent reads from it will return its default value.
  public mutating func clearLinks() {self._links = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _links: Links? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension GetProfilePageRequest: @unchecked Sendable {}
extension SetProfileInfoRequest: @unchecked Sendable {}
extension SetSettingsRequest: @unchecked Sendable {}
extension GetProfileInfoResponse: @unchecked Sendable {}
extension GetProfilePageResponse: @unchecked Sendable {}
extension GetChannelTypesResponse: @unchecked Sendable {}
extension Address: @unchecked Sendable {}
extension GetSettingsResponse: @unchecked Sendable {}
extension Contacts: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ru.zveron.contract.profile"

extension GetProfilePageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetProfilePageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "requested_profile_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.requestedProfileID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requestedProfileID != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestedProfileID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetProfilePageRequest, rhs: GetProfilePageRequest) -> Bool {
    if lhs.requestedProfileID != rhs.requestedProfileID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SetProfileInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetProfileInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "name"),
    3: .same(proto: "surname"),
    4: .standard(proto: "image_id"),
    5: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._surname) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._imageID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._surname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._imageID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SetProfileInfoRequest, rhs: SetProfileInfoRequest) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._surname != rhs._surname {return false}
    if lhs._imageID != rhs._imageID {return false}
    if lhs._address != rhs._address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SetSettingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetSettingsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "channels"),
    3: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.channels) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.channels.isEmpty {
      try visitor.visitPackedEnumField(value: self.channels, fieldNumber: 2)
    }
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SetSettingsRequest, rhs: SetSettingsRequest) -> Bool {
    if lhs.channels != rhs.channels {return false}
    if lhs._address != rhs._address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetProfileInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetProfileInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "surname"),
    4: .standard(proto: "image_id"),
    5: .same(proto: "rating"),
    6: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.surname) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.imageID) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.rating) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.surname.isEmpty {
      try visitor.visitSingularStringField(value: self.surname, fieldNumber: 3)
    }
    if self.imageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.imageID, fieldNumber: 4)
    }
    if self.rating != 0 {
      try visitor.visitSingularDoubleField(value: self.rating, fieldNumber: 5)
    }
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetProfileInfoResponse, rhs: GetProfileInfoResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.surname != rhs.surname {return false}
    if lhs.imageID != rhs.imageID {return false}
    if lhs.rating != rhs.rating {return false}
    if lhs._address != rhs._address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetProfilePageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetProfilePageResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "surname"),
    4: .standard(proto: "image_id"),
    5: .same(proto: "contacts"),
    6: .same(proto: "rating"),
    7: .standard(proto: "review_number"),
    8: .same(proto: "address"),
    9: .standard(proto: "active_lots"),
    10: .standard(proto: "closed_lots"),
    11: .standard(proto: "last_activity"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _name: String = String()
    var _surname: String = String()
    var _imageID: UInt64 = 0
    var _contacts: Contacts? = nil
    var _rating: Double = 0
    var _reviewNumber: Int32 = 0
    var _address: String = String()
    var _activeLots: [Lot] = []
    var _closedLots: [Lot] = []
    var _lastActivity: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _surname = source._surname
      _imageID = source._imageID
      _contacts = source._contacts
      _rating = source._rating
      _reviewNumber = source._reviewNumber
      _address = source._address
      _activeLots = source._activeLots
      _closedLots = source._closedLots
      _lastActivity = source._lastActivity
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._surname) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._imageID) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._contacts) }()
        case 6: try { try decoder.decodeSingularDoubleField(value: &_storage._rating) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._reviewNumber) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._address) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._activeLots) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._closedLots) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._lastActivity) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._surname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._surname, fieldNumber: 3)
      }
      if _storage._imageID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._imageID, fieldNumber: 4)
      }
      try { if let v = _storage._contacts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._rating != 0 {
        try visitor.visitSingularDoubleField(value: _storage._rating, fieldNumber: 6)
      }
      if _storage._reviewNumber != 0 {
        try visitor.visitSingularInt32Field(value: _storage._reviewNumber, fieldNumber: 7)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 8)
      }
      if !_storage._activeLots.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._activeLots, fieldNumber: 9)
      }
      if !_storage._closedLots.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._closedLots, fieldNumber: 10)
      }
      try { if let v = _storage._lastActivity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetProfilePageResponse, rhs: GetProfilePageResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._surname != rhs_storage._surname {return false}
        if _storage._imageID != rhs_storage._imageID {return false}
        if _storage._contacts != rhs_storage._contacts {return false}
        if _storage._rating != rhs_storage._rating {return false}
        if _storage._reviewNumber != rhs_storage._reviewNumber {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._activeLots != rhs_storage._activeLots {return false}
        if _storage._closedLots != rhs_storage._closedLots {return false}
        if _storage._lastActivity != rhs_storage._lastActivity {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetChannelTypesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChannelTypesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.channels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channels.isEmpty {
      try visitor.visitPackedEnumField(value: self.channels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetChannelTypesResponse, rhs: GetChannelTypesResponse) -> Bool {
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Address"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "region"),
    2: .same(proto: "town"),
    3: .same(proto: "longitude"),
    4: .same(proto: "latitude"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.town) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 1)
    }
    if !self.town.isEmpty {
      try visitor.visitSingularStringField(value: self.town, fieldNumber: 2)
    }
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 3)
    }
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address, rhs: Address) -> Bool {
    if lhs.region != rhs.region {return false}
    if lhs.town != rhs.town {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetSettingsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSettingsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "channels"),
    3: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.channels) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.channels.isEmpty {
      try visitor.visitPackedEnumField(value: self.channels, fieldNumber: 2)
    }
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetSettingsResponse, rhs: GetSettingsResponse) -> Bool {
    if lhs.channels != rhs.channels {return false}
    if lhs._address != rhs._address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Contacts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Contacts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channels"),
    2: .same(proto: "links"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.channels) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._links) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.channels.isEmpty {
      try visitor.visitPackedEnumField(value: self.channels, fieldNumber: 1)
    }
    try { if let v = self._links {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Contacts, rhs: Contacts) -> Bool {
    if lhs.channels != rhs.channels {return false}
    if lhs._links != rhs._links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
