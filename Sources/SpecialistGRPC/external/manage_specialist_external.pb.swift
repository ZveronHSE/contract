// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: manage_specialist_external.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct InfoEntity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  public var title: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ----------------------
public struct FullEducation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var educationalInstitution: String = String()

  public var faculty: String = String()

  public var specialization: String = String()

  /// Год начала
  public var startYear: Int32 = 0

  /// Год окончания обучения
  public var endYear: Int32 {
    get {return _endYear ?? 0}
    set {_endYear = newValue}
  }
  /// Returns true if `endYear` has been explicitly set.
  public var hasEndYear: Bool {return self._endYear != nil}
  /// Clears the value of `endYear`. Subsequent reads from it will return its default value.
  public mutating func clearEndYear() {self._endYear = nil}

  public var diplomaURL: String = String()

  /// показывать ли фотку диплома и зачетки клиентам
  public var showPhoto: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _endYear: Int32? = nil
}

public struct EditEducationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  public var education: FullEducation {
    get {return _education ?? FullEducation()}
    set {_education = newValue}
  }
  /// Returns true if `education` has been explicitly set.
  public var hasEducation: Bool {return self._education != nil}
  /// Clears the value of `education`. Subsequent reads from it will return its default value.
  public mutating func clearEducation() {self._education = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _education: FullEducation? = nil
}

public struct FullWorkExperience {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var organization: String = String()

  public var workTitle: String = String()

  /// Год начала
  public var startYear: Int32 = 0

  /// Год окончания обучения
  public var endYear: Int32 {
    get {return _endYear ?? 0}
    set {_endYear = newValue}
  }
  /// Returns true if `endYear` has been explicitly set.
  public var hasEndYear: Bool {return self._endYear != nil}
  /// Clears the value of `endYear`. Subsequent reads from it will return its default value.
  public mutating func clearEndYear() {self._endYear = nil}

  public var documentURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _endYear: Int32? = nil
}

public struct EditWorkExperienceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  public var work: FullWorkExperience {
    get {return _work ?? FullWorkExperience()}
    set {_work = newValue}
  }
  /// Returns true if `work` has been explicitly set.
  public var hasWork: Bool {return self._work != nil}
  /// Clears the value of `work`. Subsequent reads from it will return its default value.
  public mutating func clearWork() {self._work = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _work: FullWorkExperience? = nil
}

public struct FullAchievement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  /// Год получения
  public var year: Int32 = 0

  /// Фотография достижения
  public var documentURL: String = String()

  /// показывать ли фотку клиентам
  public var showPhoto: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EditAchievementRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  public var achievement: FullAchievement {
    get {return _achievement ?? FullAchievement()}
    set {_achievement = newValue}
  }
  /// Returns true if `achievement` has been explicitly set.
  public var hasAchievement: Bool {return self._achievement != nil}
  /// Clears the value of `achievement`. Subsequent reads from it will return its default value.
  public mutating func clearAchievement() {self._achievement = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _achievement: FullAchievement? = nil
}

public struct FullService {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var startPrice: Int32 {
    get {return _startPrice ?? 0}
    set {_startPrice = newValue}
  }
  /// Returns true if `startPrice` has been explicitly set.
  public var hasStartPrice: Bool {return self._startPrice != nil}
  /// Clears the value of `startPrice`. Subsequent reads from it will return its default value.
  public mutating func clearStartPrice() {self._startPrice = nil}

  public var endPrice: Int32 {
    get {return _endPrice ?? 0}
    set {_endPrice = newValue}
  }
  /// Returns true if `endPrice` has been explicitly set.
  public var hasEndPrice: Bool {return self._endPrice != nil}
  /// Clears the value of `endPrice`. Subsequent reads from it will return its default value.
  public mutating func clearEndPrice() {self._endPrice = nil}

  public var isRemotely: Bool = false

  public var atHome: Bool = false

  public var homeVisit: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startPrice: Int32? = nil
  fileprivate var _endPrice: Int32? = nil
}

public struct EditServiceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  public var service: FullService {
    get {return _service ?? FullService()}
    set {_service = newValue}
  }
  /// Returns true if `service` has been explicitly set.
  public var hasService: Bool {return self._service != nil}
  /// Clears the value of `service`. Subsequent reads from it will return its default value.
  public mutating func clearService() {self._service = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _service: FullService? = nil
}

public struct FullOther {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var documentURL: String = String()

  /// показывать ли фотку клиентам
  public var showPhoto: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EditOtherRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  public var other: FullOther {
    get {return _other ?? FullOther()}
    set {_other = newValue}
  }
  /// Returns true if `other` has been explicitly set.
  public var hasOther: Bool {return self._other != nil}
  /// Clears the value of `other`. Subsequent reads from it will return its default value.
  public mutating func clearOther() {self._other = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _other: FullOther? = nil
}

public struct GetProfileResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Для формирования ссылки на поделиться
  public var id: Int64 = 0

  /// Имя и фамилия
  public var name: String = String()

  /// Нет оценок или "4.9 (10 оценок)"
  public var rating: String = String()

  /// Количество отзывов - "нет отзывов" или "14 отзывов"
  public var quantityReview: String = String()

  /// Аватарка пользователя
  public var imgURL: String = String()

  /// Описание о себе
  public var description_p: String = String()

  /// Образование
  public var educations: [InfoEntity] = []

  /// Опыт работы
  public var workExperiences: [InfoEntity] = []

  /// Достижения
  public var achievements: [InfoEntity] = []

  /// разное
  public var others: [InfoEntity] = []

  /// услуги
  public var services: [InfoEntity] = []

  /// ссылки на документы
  public var documentUrls: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EditNameRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  /// фамилия
  public var surname: String = String()

  /// отчество
  public var patronymic: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Documents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var urls: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension InfoEntity: @unchecked Sendable {}
extension FullEducation: @unchecked Sendable {}
extension EditEducationRequest: @unchecked Sendable {}
extension FullWorkExperience: @unchecked Sendable {}
extension EditWorkExperienceRequest: @unchecked Sendable {}
extension FullAchievement: @unchecked Sendable {}
extension EditAchievementRequest: @unchecked Sendable {}
extension FullService: @unchecked Sendable {}
extension EditServiceRequest: @unchecked Sendable {}
extension FullOther: @unchecked Sendable {}
extension EditOtherRequest: @unchecked Sendable {}
extension GetProfileResponse: @unchecked Sendable {}
extension EditNameRequest: @unchecked Sendable {}
extension Documents: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ru.zveron.contract.specialist.manage"

extension InfoEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoEntity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InfoEntity, rhs: InfoEntity) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FullEducation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FullEducation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "educational_institution"),
    2: .same(proto: "faculty"),
    3: .same(proto: "specialization"),
    4: .standard(proto: "start_year"),
    5: .standard(proto: "end_year"),
    6: .standard(proto: "diploma_url"),
    7: .standard(proto: "show_photo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.educationalInstitution) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.faculty) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.specialization) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.startYear) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._endYear) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.diplomaURL) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.showPhoto) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.educationalInstitution.isEmpty {
      try visitor.visitSingularStringField(value: self.educationalInstitution, fieldNumber: 1)
    }
    if !self.faculty.isEmpty {
      try visitor.visitSingularStringField(value: self.faculty, fieldNumber: 2)
    }
    if !self.specialization.isEmpty {
      try visitor.visitSingularStringField(value: self.specialization, fieldNumber: 3)
    }
    if self.startYear != 0 {
      try visitor.visitSingularInt32Field(value: self.startYear, fieldNumber: 4)
    }
    try { if let v = self._endYear {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    if !self.diplomaURL.isEmpty {
      try visitor.visitSingularStringField(value: self.diplomaURL, fieldNumber: 6)
    }
    if self.showPhoto != false {
      try visitor.visitSingularBoolField(value: self.showPhoto, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FullEducation, rhs: FullEducation) -> Bool {
    if lhs.educationalInstitution != rhs.educationalInstitution {return false}
    if lhs.faculty != rhs.faculty {return false}
    if lhs.specialization != rhs.specialization {return false}
    if lhs.startYear != rhs.startYear {return false}
    if lhs._endYear != rhs._endYear {return false}
    if lhs.diplomaURL != rhs.diplomaURL {return false}
    if lhs.showPhoto != rhs.showPhoto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EditEducationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditEducationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "education"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._education) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._education {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EditEducationRequest, rhs: EditEducationRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._education != rhs._education {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FullWorkExperience: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FullWorkExperience"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "organization"),
    2: .standard(proto: "work_title"),
    3: .standard(proto: "start_year"),
    4: .standard(proto: "end_year"),
    5: .standard(proto: "document_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.organization) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workTitle) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.startYear) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._endYear) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.documentURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.organization.isEmpty {
      try visitor.visitSingularStringField(value: self.organization, fieldNumber: 1)
    }
    if !self.workTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.workTitle, fieldNumber: 2)
    }
    if self.startYear != 0 {
      try visitor.visitSingularInt32Field(value: self.startYear, fieldNumber: 3)
    }
    try { if let v = self._endYear {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    if !self.documentURL.isEmpty {
      try visitor.visitSingularStringField(value: self.documentURL, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FullWorkExperience, rhs: FullWorkExperience) -> Bool {
    if lhs.organization != rhs.organization {return false}
    if lhs.workTitle != rhs.workTitle {return false}
    if lhs.startYear != rhs.startYear {return false}
    if lhs._endYear != rhs._endYear {return false}
    if lhs.documentURL != rhs.documentURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EditWorkExperienceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditWorkExperienceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "work"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._work) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._work {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EditWorkExperienceRequest, rhs: EditWorkExperienceRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._work != rhs._work {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FullAchievement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FullAchievement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "year"),
    3: .standard(proto: "document_url"),
    4: .standard(proto: "show_photo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.year) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.documentURL) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.showPhoto) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if self.year != 0 {
      try visitor.visitSingularInt32Field(value: self.year, fieldNumber: 2)
    }
    if !self.documentURL.isEmpty {
      try visitor.visitSingularStringField(value: self.documentURL, fieldNumber: 3)
    }
    if self.showPhoto != false {
      try visitor.visitSingularBoolField(value: self.showPhoto, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FullAchievement, rhs: FullAchievement) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.year != rhs.year {return false}
    if lhs.documentURL != rhs.documentURL {return false}
    if lhs.showPhoto != rhs.showPhoto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EditAchievementRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditAchievementRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "achievement"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._achievement) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._achievement {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EditAchievementRequest, rhs: EditAchievementRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._achievement != rhs._achievement {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FullService: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FullService"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .standard(proto: "start_price"),
    3: .standard(proto: "end_price"),
    4: .standard(proto: "is_remotely"),
    5: .standard(proto: "at_home"),
    6: .standard(proto: "home_visit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._startPrice) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._endPrice) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isRemotely) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.atHome) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.homeVisit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    try { if let v = self._startPrice {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._endPrice {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    if self.isRemotely != false {
      try visitor.visitSingularBoolField(value: self.isRemotely, fieldNumber: 4)
    }
    if self.atHome != false {
      try visitor.visitSingularBoolField(value: self.atHome, fieldNumber: 5)
    }
    if self.homeVisit != false {
      try visitor.visitSingularBoolField(value: self.homeVisit, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FullService, rhs: FullService) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs._startPrice != rhs._startPrice {return false}
    if lhs._endPrice != rhs._endPrice {return false}
    if lhs.isRemotely != rhs.isRemotely {return false}
    if lhs.atHome != rhs.atHome {return false}
    if lhs.homeVisit != rhs.homeVisit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EditServiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditServiceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "service"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._service) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._service {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EditServiceRequest, rhs: EditServiceRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._service != rhs._service {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FullOther: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FullOther"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .standard(proto: "document_url"),
    3: .standard(proto: "show_photo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.documentURL) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.showPhoto) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.documentURL.isEmpty {
      try visitor.visitSingularStringField(value: self.documentURL, fieldNumber: 2)
    }
    if self.showPhoto != false {
      try visitor.visitSingularBoolField(value: self.showPhoto, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FullOther, rhs: FullOther) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.documentURL != rhs.documentURL {return false}
    if lhs.showPhoto != rhs.showPhoto {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EditOtherRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditOtherRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "other"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._other) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._other {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EditOtherRequest, rhs: EditOtherRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._other != rhs._other {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetProfileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetProfileResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "rating"),
    4: .standard(proto: "quantity_review"),
    5: .standard(proto: "img_url"),
    6: .same(proto: "description"),
    7: .same(proto: "educations"),
    8: .standard(proto: "work_experiences"),
    9: .same(proto: "achievements"),
    10: .same(proto: "others"),
    11: .same(proto: "services"),
    12: .standard(proto: "document_urls"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.rating) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.quantityReview) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.imgURL) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.educations) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.workExperiences) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.achievements) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.others) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.services) }()
      case 12: try { try decoder.decodeRepeatedStringField(value: &self.documentUrls) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.rating.isEmpty {
      try visitor.visitSingularStringField(value: self.rating, fieldNumber: 3)
    }
    if !self.quantityReview.isEmpty {
      try visitor.visitSingularStringField(value: self.quantityReview, fieldNumber: 4)
    }
    if !self.imgURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imgURL, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    if !self.educations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.educations, fieldNumber: 7)
    }
    if !self.workExperiences.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workExperiences, fieldNumber: 8)
    }
    if !self.achievements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.achievements, fieldNumber: 9)
    }
    if !self.others.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.others, fieldNumber: 10)
    }
    if !self.services.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.services, fieldNumber: 11)
    }
    if !self.documentUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.documentUrls, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetProfileResponse, rhs: GetProfileResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.rating != rhs.rating {return false}
    if lhs.quantityReview != rhs.quantityReview {return false}
    if lhs.imgURL != rhs.imgURL {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.educations != rhs.educations {return false}
    if lhs.workExperiences != rhs.workExperiences {return false}
    if lhs.achievements != rhs.achievements {return false}
    if lhs.others != rhs.others {return false}
    if lhs.services != rhs.services {return false}
    if lhs.documentUrls != rhs.documentUrls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EditNameRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditNameRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "surname"),
    3: .same(proto: "patronymic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.surname) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.patronymic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.surname.isEmpty {
      try visitor.visitSingularStringField(value: self.surname, fieldNumber: 2)
    }
    if !self.patronymic.isEmpty {
      try visitor.visitSingularStringField(value: self.patronymic, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EditNameRequest, rhs: EditNameRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.surname != rhs.surname {return false}
    if lhs.patronymic != rhs.patronymic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Documents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Documents"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "urls"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.urls) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.urls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.urls, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Documents, rhs: Documents) -> Bool {
    if lhs.urls != rhs.urls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
